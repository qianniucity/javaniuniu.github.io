I"(
<ol>
  <li>@Slf4j 一般注解在类的开头 <a href="https://blog.csdn.net/fanrenxiang/article/details/81012803">详情参考</a></li>
  <li>@EqualsAndHashCode(callSuper = false) 作用就是自动的给model bean实现equals方法和hashcode方法，callSuper = false 表示生成的 hashcode 包括父类属性 <a href="https://blog.csdn.net/qq_27093465/article/details/90056695">详情参考</a></li>
  <li>lombok
    <ul>
      <li>@Data ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法</li>
      <li>@AllArgsConstructor ： 注在类上，提供类的全参构造</li>
      <li>@NoArgsConstructor ： 注在类上，提供类的无参构造</li>
      <li>@Setter ： 注在属性上，提供 set 方法</li>
      <li>@Getter ： 注在属性上，提供 get 方法</li>
      <li>@EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法</li>
      <li>@Log4j/@Slf4j ： 注在类上，提供对应的 Logger 对象，变量名为 log   ，private static final Logger log = LoggerFactory.getLogger(UserController.class);</li>
    </ul>
  </li>
  <li>@Value 给属性赋值 <a href="https://www.cnblogs.com/wangbin2188/p/9014837.html">@Value注入</a></li>
  <li>@Target注解用法(元注解)  <a href="https://www.cnblogs.com/unknows/p/10261539.html">取值(ElementType)有</a></li>
  <li>@Retention(RetentionPolicy.RUNTIME)  解不仅被保存到class文件中，jvm加载class文件之后，仍然存在 <a href="https://www.cnblogs.com/a8457013/p/9965551.html">RetentionPolicy.RUNTIME</a></li>
  <li>Java自定义注解用在请求拦截中比较常用 <a href="https://www.cnblogs.com/jajian/p/9695055.html">Java自定义注解</a></li>
  <li>@Aspect AOP为Aspect Oriented Programming的缩写，意为：面向切面编程 <a href="https://blog.csdn.net/fz13768884254/article/details/83538709">@Aspect 注解使用详解</a></li>
  <li>@Order 定义Spring IOC容器中Bean的执行顺序的优先级 <a href="https://blog.csdn.net/yaomingyang/article/details/86649072">浅谈Spring @Order注解的使用</a></li>
  <li>@EnableGlobalMethodSecurity(prePostEnabled=true) 这个注解，会从SecurityContext中取出Authencation对象，然后再取出Collection<GrantedAuthority> authorites集合。然后比对当前用户是否有权限"readArtical"。实际上就是比对集合中是否有那个GrantedAuthority的getAuthority()方法返回的字符串与"radArtical"匹配。</GrantedAuthority></li>
  <li><a href="https://www.cnblogs.com/vi3nty/p/10642456.html">为啥要重写hashcode和equals方法</a></li>
</ol>
:ET