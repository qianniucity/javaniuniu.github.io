I"Ü4<h5 id="ä¸€å¥è¯ç®€ä»‹">ä¸€å¥è¯ç®€ä»‹</h5>
<p>JAVAåå°„æœºåˆ¶æ˜¯åœ¨è¿è¡ŒçŠ¶æ€ä¸­ï¼Œå¯¹äºä»»æ„ä¸€ä¸ªç±»ï¼Œéƒ½èƒ½å¤ŸçŸ¥é“è¿™ä¸ªç±»çš„æ‰€æœ‰å±æ€§å’Œæ–¹æ³•ï¼›å¯¹äºä»»æ„ä¸€ä¸ªå¯¹è±¡ï¼Œéƒ½èƒ½å¤Ÿè°ƒç”¨å®ƒçš„ä»»æ„æ–¹æ³•å’Œå±æ€§ï¼›è¿™ç§åŠ¨æ€è·å–ä¿¡æ¯ä»¥åŠåŠ¨æ€è°ƒç”¨å¯¹è±¡æ–¹æ³•çš„åŠŸèƒ½ç§°ä¸ºjavaè¯­è¨€çš„åå°„æœºåˆ¶</p>

<h5 id="ä½¿ç”¨åœºæ™¯">ä½¿ç”¨åœºæ™¯</h5>
<ul>
  <li>åœ¨æ—¥å¸¸çš„ç¬¬ä¸‰æ–¹åº”ç”¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œç»å¸¸ä¼šé‡åˆ°æŸä¸ªç±»çš„æŸä¸ªæˆå‘˜å˜é‡ã€æ–¹æ³•æˆ–æ˜¯å±æ€§æ˜¯ç§æœ‰çš„æˆ–æ˜¯åªå¯¹ç³»ç»Ÿåº”ç”¨å¼€æ”¾ï¼Œè¿™æ—¶å€™å°±å¯ä»¥åˆ©ç”¨Javaçš„åå°„æœºåˆ¶é€šè¿‡åå°„æ¥è·å–æ‰€éœ€çš„ç§æœ‰æˆå‘˜æˆ–æ˜¯æ–¹æ³•</li>
  <li>ä¸»è¦åº”ç”¨äºæ¡†æ¶ä¸­
```java
package com.javaniuniu.scshorlsweb.system.utils.reflect;</li>
</ul>

<p>import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.Validate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>

<p>import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;</p>

<p>/**</p>
<ul>
  <li>åå°„å·¥å…·ç±».
 *</li>
  <li>æä¾›è°ƒç”¨getter/setteræ–¹æ³•, è®¿é—®ç§æœ‰å˜é‡, è°ƒç”¨ç§æœ‰æ–¹æ³•, è·å–æ³›å‹ç±»å‹Class, è¢«AOPè¿‡çš„çœŸå®ç±»ç­‰å·¥å…·å‡½æ•°.</li>
  <li>
    <p>//TODO åå°„å·¥å…·ç±»
 */
public class Reflections
{
 private static final String SETTER_PREFIX = â€œsetâ€;</p>

    <p>private static final String GETTER_PREFIX = â€œgetâ€;</p>

    <p>private static final String CGLIB_CLASS_SEPARATOR = â€œ$$â€;</p>

    <p>private static Logger logger = LoggerFactory.getLogger(Reflections.class);</p>

    <p>/**</p>
    <ul>
      <li>è°ƒç”¨Getteræ–¹æ³•.
  */
 public static Object invokeGetter(Object obj, String propertyName) {
 String getterMethodName = GETTER_PREFIX + StringUtils.capitalize(propertyName);
 return invokeMethod(obj, getterMethodName, new Class[] {}, new Object[] {});
 }</li>
    </ul>

    <p>/**</p>
    <ul>
      <li>è°ƒç”¨Setteræ–¹æ³•, ä»…åŒ¹é…æ–¹æ³•åã€‚
  */
 public static void invokeSetter(Object obj, String propertyName, Object value) {
 String setterMethodName = SETTER_PREFIX + StringUtils.capitalize(propertyName);
 invokeMethodByName(obj, setterMethodName, new Object[] { value });
 }</li>
    </ul>

    <p>/**</p>
    <ul>
      <li>
        <p>ç›´æ¥è¯»å–å¯¹è±¡å±æ€§å€¼, æ— è§†private/protectedä¿®é¥°ç¬¦, ä¸ç»è¿‡getterå‡½æ•°.
  */
 public static Object getFieldValue(final Object obj, final String fieldName) {
 Field field = getAccessibleField(obj, fieldName);</p>

        <p>if (field == null) {
     throw new IllegalArgumentException(â€œCould not find field [â€ + fieldName + â€œ] on target [â€ + obj + â€œ]â€);
 }</p>

        <p>Object result = null;
 try {
     result = field.get(obj);
 } catch (IllegalAccessException e) {
     logger.error(â€œä¸å¯èƒ½æŠ›å‡ºçš„å¼‚å¸¸{}â€, e.getMessage());
 }
 return result;
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>
        <p>ç›´æ¥è®¾ç½®å¯¹è±¡å±æ€§å€¼, æ— è§†private/protectedä¿®é¥°ç¬¦, ä¸ç»è¿‡setterå‡½æ•°.
  */
 public static void setFieldValue(final Object obj, final String fieldName, final Object value) {
 Field field = getAccessibleField(obj, fieldName);</p>

        <p>if (field == null) {
     throw new IllegalArgumentException(â€œCould not find field [â€ + fieldName + â€œ] on target [â€ + obj + â€œ]â€);
 }</p>

        <p>try {
     field.set(obj, value);
 } catch (IllegalAccessException e) {
     logger.error(â€œä¸å¯èƒ½æŠ›å‡ºçš„å¼‚å¸¸:{}â€, e.getMessage());
 }
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>ç›´æ¥è°ƒç”¨å¯¹è±¡æ–¹æ³•, æ— è§†private/protectedä¿®é¥°ç¬¦.</li>
      <li>ç”¨äºä¸€æ¬¡æ€§è°ƒç”¨çš„æƒ…å†µï¼Œå¦åˆ™åº”ä½¿ç”¨getAccessibleMethod()å‡½æ•°è·å¾—Methodååå¤è°ƒç”¨.</li>
      <li>
        <p>åŒæ—¶åŒ¹é…æ–¹æ³•å+å‚æ•°ç±»å‹ï¼Œ
  */
 public static Object invokeMethod(final Object obj, final String methodName, final Class&lt;?&gt;[] parameterTypes,
                               final Object[] args) {
 Method method = getAccessibleMethod(obj, methodName, parameterTypes);
 if (method == null) {
     throw new IllegalArgumentException(â€œCould not find method [â€ + methodName + â€œ] on target [â€ + obj + â€œ]â€);
 }</p>

        <p>try {
     return method.invoke(obj, args);
 } catch (Exception e) {
     throw convertReflectionExceptionToUnchecked(e);
 }
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>ç›´æ¥è°ƒç”¨å¯¹è±¡æ–¹æ³•, æ— è§†private/protectedä¿®é¥°ç¬¦ï¼Œ</li>
      <li>ç”¨äºä¸€æ¬¡æ€§è°ƒç”¨çš„æƒ…å†µï¼Œå¦åˆ™åº”ä½¿ç”¨getAccessibleMethodByName()å‡½æ•°è·å¾—Methodååå¤è°ƒç”¨.</li>
      <li>
        <p>åªåŒ¹é…å‡½æ•°åï¼Œå¦‚æœæœ‰å¤šä¸ªåŒåå‡½æ•°è°ƒç”¨ç¬¬ä¸€ä¸ªã€‚
  */
 public static Object invokeMethodByName(final Object obj, final String methodName, final Object[] args) {
 Method method = getAccessibleMethodByName(obj, methodName);
 if (method == null) {
     throw new IllegalArgumentException(â€œCould not find method [â€ + methodName + â€œ] on target [â€ + obj + â€œ]â€);
 }</p>

        <p>try {
     return method.invoke(obj, args);
 } catch (Exception e) {
     throw convertReflectionExceptionToUnchecked(e);
 }
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>å¾ªç¯å‘ä¸Šè½¬å‹, è·å–å¯¹è±¡çš„DeclaredField, å¹¶å¼ºåˆ¶è®¾ç½®ä¸ºå¯è®¿é—®.
  *</li>
      <li>å¦‚å‘ä¸Šè½¬å‹åˆ°Objectä»æ— æ³•æ‰¾åˆ°, è¿”å›null.
  */
 public static Field getAccessibleField(final Object obj, final String fieldName) {
 Validate.notNull(obj, â€œobject canâ€™t be nullâ€);
 Validate.notBlank(fieldName, â€œfieldName canâ€™t be blankâ€);
 for (Class&lt;?&gt; superClass = obj.getClass(); superClass != Object.class; superClass = superClass.getSuperclass()) {
     try {
         Field field = superClass.getDeclaredField(fieldName);
         makeAccessible(field);
         return field;
     } catch (NoSuchFieldException e) {// NOSONAR
         // Fieldä¸åœ¨å½“å‰ç±»å®šä¹‰,ç»§ç»­å‘ä¸Šè½¬å‹
     }
 }
 return null;
 }</li>
    </ul>

    <p>/**</p>
    <ul>
      <li>å¾ªç¯å‘ä¸Šè½¬å‹, è·å–å¯¹è±¡çš„DeclaredMethod,å¹¶å¼ºåˆ¶è®¾ç½®ä¸ºå¯è®¿é—®.</li>
      <li>å¦‚å‘ä¸Šè½¬å‹åˆ°Objectä»æ— æ³•æ‰¾åˆ°, è¿”å›null.</li>
      <li>åŒ¹é…å‡½æ•°å+å‚æ•°ç±»å‹ã€‚
  *</li>
      <li>
        <p>ç”¨äºæ–¹æ³•éœ€è¦è¢«å¤šæ¬¡è°ƒç”¨çš„æƒ…å†µ. å…ˆä½¿ç”¨æœ¬å‡½æ•°å…ˆå–å¾—Method,ç„¶åè°ƒç”¨Method.invoke(Object obj, Objectâ€¦ args)
  */
 public static Method getAccessibleMethod(final Object obj, final String methodName,
                                      final Class&lt;?&gt;â€¦ parameterTypes) {
 Validate.notNull(obj, â€œobject canâ€™t be nullâ€);
 Validate.notBlank(methodName, â€œmethodName canâ€™t be blankâ€);</p>

        <p>for (Class&lt;?&gt; searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) {
     try {
         Method method = searchType.getDeclaredMethod(methodName, parameterTypes);
         makeAccessible(method);
         return method;
     } catch (NoSuchMethodException e) {
         // Methodä¸åœ¨å½“å‰ç±»å®šä¹‰,ç»§ç»­å‘ä¸Šè½¬å‹
     }
 }
 return null;
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>å¾ªç¯å‘ä¸Šè½¬å‹, è·å–å¯¹è±¡çš„DeclaredMethod,å¹¶å¼ºåˆ¶è®¾ç½®ä¸ºå¯è®¿é—®.</li>
      <li>å¦‚å‘ä¸Šè½¬å‹åˆ°Objectä»æ— æ³•æ‰¾åˆ°, è¿”å›null.</li>
      <li>åªåŒ¹é…å‡½æ•°åã€‚
  *</li>
      <li>
        <p>ç”¨äºæ–¹æ³•éœ€è¦è¢«å¤šæ¬¡è°ƒç”¨çš„æƒ…å†µ. å…ˆä½¿ç”¨æœ¬å‡½æ•°å…ˆå–å¾—Method,ç„¶åè°ƒç”¨Method.invoke(Object obj, Objectâ€¦ args)
  */
 public static Method getAccessibleMethodByName(final Object obj, final String methodName) {
 Validate.notNull(obj, â€œobject canâ€™t be nullâ€);
 Validate.notBlank(methodName, â€œmethodName canâ€™t be blankâ€);</p>

        <p>for (Class&lt;?&gt; searchType = obj.getClass(); searchType != Object.class; searchType = searchType.getSuperclass()) {
     Method[] methods = searchType.getDeclaredMethods();
     for (Method method : methods) {
         if (method.getName().equals(methodName)) {
             makeAccessible(method);
             return method;
         }
     }
 }
 return null;
 }</p>
      </li>
    </ul>

    <p>/**</p>
    <ul>
      <li>æ”¹å˜private/protectedçš„æ–¹æ³•ä¸ºpublicï¼Œå°½é‡ä¸è°ƒç”¨å®é™…æ”¹åŠ¨çš„è¯­å¥ï¼Œé¿å…JDKçš„SecurityManageræŠ±æ€¨ã€‚
  */
 public static void makeAccessible(Method method) {
 if ((!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers()))
         &amp;&amp; !method.isAccessible()) {
     method.setAccessible(true);
 }
 }</li>
    </ul>

    <p>/**</p>
    <ul>
      <li>æ”¹å˜private/protectedçš„æˆå‘˜å˜é‡ä¸ºpublicï¼Œå°½é‡ä¸è°ƒç”¨å®é™…æ”¹åŠ¨çš„è¯­å¥ï¼Œé¿å…JDKçš„SecurityManageræŠ±æ€¨ã€‚
  */
 public static void makeAccessible(Field field) {
 if ((!Modifier.isPublic(field.getModifiers()) || !Modifier.isPublic(field.getDeclaringClass().getModifiers()) || Modifier
         .isFinal(field.getModifiers())) &amp;&amp; !field.isAccessible()) {
     field.setAccessible(true);
 }
 }</li>
    </ul>

    <p>/**</p>
    <ul>
      <li>é€šè¿‡åå°„, è·å¾—Classå®šä¹‰ä¸­å£°æ˜çš„æ³›å‹å‚æ•°çš„ç±»å‹, æ³¨æ„æ³›å‹å¿…é¡»å®šä¹‰åœ¨çˆ¶ç±»å¤„</li>
      <li>å¦‚æ— æ³•æ‰¾åˆ°, è¿”å›Object.class.</li>
      <li>eg.</li>
      <li>public UserDao extends HibernateDao<User>
  *</User></li>
      <li>@param clazz The class to introspect</li>
      <li>@return the first generic declaration, or Object.class if cannot be determined
  */
 public static <T> Class<T> getClassGenricType(final Class clazz) {
 return getClassGenricType(clazz, 0);
 }</T></T></li>
    </ul>

    <p>public static <T> Class<T> getClassGenricType(final Type type){
     if (type instanceof ParameterizedType) {
         ParameterizedType paramType = (ParameterizedType) type;
         Type[] argTypes = paramType.getActualTypeArguments();
         if (argTypes.length &gt; 0) {
             if (logger.isDebugEnabled()){
                 logger.debug("Generic type is: {}",argTypes[0]);
             }
             return (Class<T>) argTypes[0];
         }
     }
     return (Class<T>) type;
 }</T></T></T></T></p>

    <p>/**</p>
    <ul>
      <li>é€šè¿‡åå°„, è·å¾—Classå®šä¹‰ä¸­å£°æ˜çš„çˆ¶ç±»çš„æ³›å‹å‚æ•°çš„ç±»å‹.</li>
      <li>å¦‚æ— æ³•æ‰¾åˆ°, è¿”å›Object.class.
  *</li>
      <li>å¦‚public UserDao extends HibernateDao&lt;User,Long&gt;
  *</li>
      <li>@param clazz clazz The class to introspect</li>
      <li>@param index the Index of the generic ddeclaration,start from 0.</li>
      <li>
        <p>@return the index generic declaration, or Object.class if cannot be determined
  */
 public static Class getClassGenricType(final Class clazz, final int index) {</p>

        <p>Type genType = clazz.getGenericSuperclass();</p>

        <p>if (!(genType instanceof ParameterizedType)) {
     logger.warn(clazz.getSimpleName() + â€œâ€˜s superclass not ParameterizedTypeâ€);
     return Object.class;
 }</p>

        <p>Type[] params = ((ParameterizedType) genType).getActualTypeArguments();</p>

        <p>if ((index &gt;= params.length) || (index &lt; 0)) {
     logger.warn(â€œIndex: â€œ + index + â€œ, Size of â€œ + clazz.getSimpleName() + â€œâ€˜s Parameterized Type: â€œ
             + params.length);
     return Object.class;
 }
 if (!(params[index] instanceof Class)) {
     logger.warn(clazz.getSimpleName() + â€œ not set the actual class on superclass generic parameterâ€);
     return Object.class;
 }</p>

        <p>return (Class) params[index];
 }</p>
      </li>
    </ul>

    <p>public static Class<?> getUserClass(Object instance) {
     Validate.notNull(instance, "Instance must not be null");
     Class clazz = instance.getClass();
     if ((clazz != null) && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
         Class<?> superClass = clazz.getSuperclass();
         if ((superClass != null) &amp;&amp; !Object.class.equals(superClass)) {
             return superClass;
         }
     }
     return clazz;</p>

    <p>}</p>

    <p>/**</p>
    <ul>
      <li>
        <p>å°†åå°„æ—¶çš„checked exceptionè½¬æ¢ä¸ºunchecked exception.
  */
 public static RuntimeException convertReflectionExceptionToUnchecked(Exception e) {
 if ((e instanceof IllegalAccessException) || (e instanceof IllegalArgumentException)
         || (e instanceof NoSuchMethodException)) {
     return new IllegalArgumentException(e);
 } else if (e instanceof InvocationTargetException) {
     return new RuntimeException(((InvocationTargetException) e).getTargetException());
 } else if (e instanceof RuntimeException) {
     return (RuntimeException) e;
 }
 return new RuntimeException(â€œUnexpected Checked Exception.â€, e);
 }
 static class Users{
 private int id = 1;
 private String name = â€œminpâ€;
 private int getId() {</p>

        <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> return 1;  } // //		private void setId(int i) { //			id =i; //		}  }
</code></pre></div>        </div>
      </li>
    </ul>

    <p>public static void main(String[] args) {
     invokeGetter(new Users(),â€idâ€);
//		getAccessibleMethod(new Users(),â€getIdâ€,null);
//
//		getUserClass(new Users());
 }
}</p>
  </li>
</ul>

<p>```</p>

<p><strong>å‚è€ƒé“¾æ¥</strong></p>
<ul>
  <li><a href="https://www.jianshu.com/p/9be58ee20dee">Javaé«˜çº§ç‰¹æ€§â€”â€”åå°„</a></li>
  <li><a href="https://blog.csdn.net/qsbbl/article/details/85801571">ã€javaåå°„ã€‘åå°„æ˜¯å•¥ï¼Ÿæ˜¯å¹²å•¥ç”¨çš„ï¼Ÿ</a></li>
</ul>
:ET