---
title: 一句话介绍
permalink: /java/one/01
tags: java基础
key: java-one-2020-08-28-01
---
# what why how
# 相应的查下  某些技术存在的坑 编写相应的代码来试错
- mysql 分库分表 有哪些技术 这些技术有哪些坑
- mysql 读写分离 有哪些技术 这些技术有哪些坑
  - mycat
  - springjdbc
- linkedHashMap 有哪些应用场景 存数据有什么缺点
  - 通过LUC算法，当linkedHashMap 满了之后 可以会自动删除使用最少的信息
  - linkedHashMap 含有linked 在插入和删除上的缺陷
- redis有哪些必须要用到的技术点
  - 倒计时
  -
- 如何处理大文件的问题
- init方法和内部类有什么区别
- 内部类
  -  内部类解决了java不能多继承的问题
- 枚举为什么可以直接使用
  - 枚举类默认被 final static 修饰
  - 枚举类的成员变量也 默认被 final static 修饰
- hashmap treemap linkedhashmap 对比
  - 一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果要按顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,用LinkedHashMap 可以实现,它还可以按读取顺序来排列.
  - linkedhashmap 在hashmap的基础上增加了linked，在加快了遍历的速度
  - treeMap 拍好顺序，在查找的时候效率比较高，插入的时候效率也没那么低
  - 在多线程高并发的情况下，有ConcurrentSkipListMap 提带treemap
- 多线程使用场景
  -
- lock 如何给对象加锁
  - 无
-  1：A线程正在执行一个对象中的同步方法，B线程是否可以同时执行同一个对象中的非同步方法？
   2：同上，B线程是否可以同时执行同一个对象中的另一个同步方法？
   3：线程抛出异常会释放锁吗？
   4：volatile和synchronized区别？
   5：写一个程序，证明AtomXXX类比synchronized更高效
   6：AtomXXX类可以保证可见性吗？请写一个程序来证明
   7：写一个程序证明AtomXXX类的多个方法并不构成原子性
   8：写一个程序模拟死锁
   9：写一个程序，在main线程中启动100个线程，100个线程完成后，主线程打印“完成”，使用join()和countdownlatch都可以完成，请比较异同。
   10：一个高效的游戏服务器应该如何设计架构？
- 限流
  - Guava RateLimter
- 乐观锁 悲观锁 自旋锁 读写锁(共享锁，排他锁)，分段锁 以及在java中的实现方式
  分别对应 CAS   syn   CAS    ReadWriteLock      LongAdder
- redis 击穿的概念
- 并发和并行的区别
  - 并发是指任务提交，并行指任务执行
- 创建线程为什么那么昂贵？
  - 必须为线程堆栈分配并初始化一大块内存。
  - 需要进行系统调用以在主机OS中创建/注册本机线程。
  - 需要创建，初始化描述符并将其添加到JVM内部数据结构中
- 多线程的目的 大概有两个：
  - __避免阻塞异步调用：__ 一是把程序细分成几个功能相对独立的模块，防止其中一个功能模块阻塞导致整个程序假死
  - __提高运行效率：__ 比如多个核同时跑，或者单核里面，某个线程进行IO操作时，另一个线程可以同时执行
- 工厂方法适合在单个产品上做纬度扩展
- 抽象工厂适合在产品族的纬度上扩展
- 设计模式
  - 工厂模式典型的应用 springioc
  - mediate 调节模式 典型应用 消息中间件
  - mvc 分离
  - 对修改关闭，对扩展开放
  - 高内聚，低耦合
  - 通过单例模式降低耦合度，比如某个类作为其他类方法的参数时，可以通过直接使用单例类，而不需要作为参数传递
  - 构造方法一个够用绝对不要写两个，每多一个构造函数都需要维护
  - 继承是直接继承相应的父类，聚合是实现共同的接口，比如父类实现了什么接口，相应的也去实现，以达到可以控制所有实现了该接口的所有类
  - 内部类，可以保证只让本类调用，不被外部的类使用
  - 由普通的类来实现接口，必须将接口所有抽象方法重写
  - 由抽象类来实现接口，则不必重写接口的方法。可以全部不重写或只重写一部分方法。
  - 在不确定使用接口还是抽象类修饰的时候，一般形容词用接口，名称用抽象类



- 数组与链表的区别

| 数组                                 | 链表                         |
| ------------------------------------ | ---------------------------- |
| 数组静态分配内存，                   | 链表动态分配内存；           |
| 数组在内存中连续，                   | 链表不连续；                 |
| 数组元素在栈区，                     | 链表元素在堆区；             |
| 数组利用下标定位，时间复杂度为O(1)， | 链表定位元素时间复杂度O(n)； |
| 数组插入或删除元素的时间复杂度O(n)， | 链表的时间复杂度O(1)。       |
