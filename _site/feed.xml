<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-08-24T23:26:05+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JAVA 牛牛</title><subtitle>主要是想看下自己还能在多做些什么
</subtitle><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><entry><title type="html">tcp nio epoll等基本技术知识</title><link href="http://localhost:4000/mianshi/tcp/nio/01" rel="alternate" type="text/html" title="tcp nio epoll等基本技术知识" /><published>2020-08-24T00:00:00+08:00</published><updated>2020-08-24T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/tcp/nio/tcp%20nio%20epoll%E7%AD%89%E5%9F%BA%E6%9C%AC%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86</id><content type="html" xml:base="http://localhost:4000/mianshi/tcp/nio/01">&lt;h4 id=&quot;tcp&quot;&gt;TCP&lt;/h4&gt;

&lt;p&gt;应用层–&amp;gt;传输层–&amp;gt;网络层–&amp;gt;链路层–物理层&lt;/p&gt;

&lt;p&gt;三次握手&lt;/p&gt;

&lt;p&gt;四次分手&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/nio/0824/Jietu20200824-155730@2x.jpg&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;io消耗&quot;&gt;IO消耗&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;程序调用&lt;/li&gt;
  &lt;li&gt;用户态调用切换到系统调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;bio&quot;&gt;BIO&lt;/h4&gt;

&lt;p&gt;每个线程对应每个连接&lt;/p&gt;

&lt;p&gt;优势：可接收很多的连接&lt;/p&gt;

&lt;p&gt;问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程内存浪费&lt;/li&gt;
  &lt;li&gt;cpu调度消耗&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根本原因：&lt;/p&gt;

&lt;p&gt;​	BLOCKING 阻塞： accept recv&lt;/p&gt;

&lt;p&gt;演变的解决方法 –&amp;gt;NONBLOCKING  非阻塞&lt;/p&gt;

&lt;h4 id=&quot;nio&quot;&gt;NIO&lt;/h4&gt;

&lt;p&gt;New IO&lt;/p&gt;

&lt;p&gt;NONBLOCKING&lt;/p&gt;

&lt;p&gt;优势：避免多线程问题&lt;/p&gt;

&lt;p&gt;弊端：假设有1w个连接，只有一个发来数据，每循环一次&lt;/p&gt;

&lt;p&gt;其实都需要向内核发生1w次reav系统调用，这里有9999是无意义的&lt;/p&gt;

&lt;p&gt;消耗时间和资源（用户空间向内核空间的循环遍历，复杂度在系统调用上）&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;com.mashibing.io.nio&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.IOException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.net.InetSocketAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.ByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.channels.SelectionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.channels.Selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.channels.ServerSocketChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.channels.SocketChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Server&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ServerSocketChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ServerSocketChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InetSocketAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8888&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;configureBlocking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;server started, listening on :&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLocalAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Selector&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;OP_ACCEPT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;selectedKeys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAcceptable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;ServerSocketChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ServerSocketChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;SocketChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ssc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;configureBlocking&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//new Client&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;//String hostIP = ((InetSocketAddress)sc.getRemoteAddress()).getHostString();&lt;/span&gt;

			&lt;span class=&quot;cm&quot;&gt;/*
			log.info(&quot;client &quot; + hostIP + &quot; trying  to connect&quot;);
			for(int i=0; i&amp;lt;clients.size(); i++) {
				String clientHostIP = clients.get(i).clientAddress.getHostString();
				if(hostIP.equals(clientHostIP)) {
					log.info(&quot;this client has already connected! is he alvie &quot; + clients.get(i).live);
					sc.close();
					return;
				}
			}*/&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SelectionKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;OP_READ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isReadable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//flip&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;SocketChannel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;SocketChannel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;allocate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;512&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                &lt;span class=&quot;nc&quot;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufferToWrite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;wrap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;HelloClient&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBytes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bufferToWrite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;sc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;多路复用&quot;&gt;多路复用&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;同步IO模型:&lt;/strong&gt;   &lt;strong&gt;如果成自己读取IO，那么这个IO模型，无论是BIO，NIO，多路复用器，都叫做 同步IO模型&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;多路复用器：&lt;/strong&gt;还是得自己来读取数据&lt;/li&gt;
  &lt;li&gt;select，poll，epoll 都是同步的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优势：通过一次系统调用，把fds，传递给内核，内核进行遍历，想多NIO的遍历，多路复用减少了系统调用次数&lt;/p&gt;

&lt;p&gt;弊端：1. 因为在where循环中，所有会出现重复传递数据到系统调用&lt;/p&gt;

&lt;p&gt;​					- 解决方法：内核开辟内存空间保留fd&lt;/p&gt;

&lt;p&gt;​			2. 每次select，poll 都都用重复遍历全量的fd&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;shell命令 工具&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;strace 追踪io 可打印出系统调用日志&lt;/li&gt;
&lt;/ul&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">TCP 应用层–&amp;gt;传输层–&amp;gt;网络层–&amp;gt;链路层–物理层 三次握手 四次分手 IO消耗 程序调用 用户态调用切换到系统调用 BIO 每个线程对应每个连接 优势：可接收很多的连接 问题： 线程内存浪费 cpu调度消耗 根本原因： ​ BLOCKING 阻塞： accept recv 演变的解决方法 –&amp;gt;NONBLOCKING 非阻塞 NIO New IO NONBLOCKING 优势：避免多线程问题 弊端：假设有1w个连接，只有一个发来数据，每循环一次 其实都需要向内核发生1w次reav系统调用，这里有9999是无意义的 消耗时间和资源（用户空间向内核空间的循环遍历，复杂度在系统调用上） package com.mashibing.io.nio; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Set; public class Server { public static void main(String[] args) throws IOException { ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8888)); ssc.configureBlocking(false); System.out.println(&quot;server started, listening on :&quot; + ssc.getLocalAddress()); Selector selector = Selector.open(); ssc.register(selector, SelectionKey.OP_ACCEPT); while(true) { selector.select(); Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys(); Iterator&amp;lt;SelectionKey&amp;gt; it = keys.iterator(); while(it.hasNext()) { SelectionKey key = it.next(); it.remove(); handle(key); } } } private static void handle(SelectionKey key) { if(key.isAcceptable()) { try { ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept(); sc.configureBlocking(false); //new Client // //String hostIP = ((InetSocketAddress)sc.getRemoteAddress()).getHostString(); /* log.info(&quot;client &quot; + hostIP + &quot; trying to connect&quot;); for(int i=0; i&amp;lt;clients.size(); i++) { String clientHostIP = clients.get(i).clientAddress.getHostString(); if(hostIP.equals(clientHostIP)) { log.info(&quot;this client has already connected! is he alvie &quot; + clients.get(i).live); sc.close(); return; } }*/ sc.register(key.selector(), SelectionKey.OP_READ ); } catch (IOException e) { e.printStackTrace(); } finally { } } else if (key.isReadable()) { //flip SocketChannel sc = null; try { sc = (SocketChannel)key.channel(); ByteBuffer buffer = ByteBuffer.allocate(512); buffer.clear(); int len = sc.read(buffer); if(len != -1) { System.out.println(new String(buffer.array(), 0, len)); } ByteBuffer bufferToWrite = ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes()); sc.write(bufferToWrite); } catch (IOException e) { e.printStackTrace(); } finally { if(sc != null) { try { sc.close(); } catch (IOException e) { e.printStackTrace(); } } } } } } 多路复用 同步IO模型: 如果成自己读取IO，那么这个IO模型，无论是BIO，NIO，多路复用器，都叫做 同步IO模型 多路复用器：还是得自己来读取数据 select，poll，epoll 都是同步的 优势：通过一次系统调用，把fds，传递给内核，内核进行遍历，想多NIO的遍历，多路复用减少了系统调用次数 弊端：1. 因为在where循环中，所有会出现重复传递数据到系统调用 ​ - 解决方法：内核开辟内存空间保留fd ​ 2. 每次select，poll 都都用重复遍历全量的fd shell命令 工具 strace 追踪io 可打印出系统调用日志</summary></entry><entry><title type="html">SpringCloud面试题</title><link href="http://localhost:4000/mianshi/SpringCloud/0823/01" rel="alternate" type="text/html" title="SpringCloud面试题" /><published>2020-08-23T00:00:00+08:00</published><updated>2020-08-23T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/SpringCloud/0823/springcloud%E9%9D%A2%E8%AF%95%E9%A2%98</id><content type="html" xml:base="http://localhost:4000/mianshi/SpringCloud/0823/01">&lt;ol&gt;
  &lt;li&gt;什么是微服务？&lt;/li&gt;
  &lt;li&gt;微服务之间如何独立通讯的?&lt;/li&gt;
  &lt;li&gt;SpringCloud 和 Dubbo 有哪些区别?&lt;/li&gt;
  &lt;li&gt;SpringBoot 和 SpringCloud 之间关系？&lt;/li&gt;
  &lt;li&gt;什么是熔断？什么是服务降级？&lt;/li&gt;
  &lt;li&gt;微服务的优缺点是什么？说下你在项目中碰到的坑。&lt;/li&gt;
  &lt;li&gt;eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？&lt;/li&gt;
  &lt;li&gt;你所知道微服务的技术栈有哪些？列举一二。&lt;/li&gt;
  &lt;li&gt;什么是微服务架构？&lt;/li&gt;
&lt;/ol&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">什么是微服务？ 微服务之间如何独立通讯的? SpringCloud 和 Dubbo 有哪些区别? SpringBoot 和 SpringCloud 之间关系？ 什么是熔断？什么是服务降级？ 微服务的优缺点是什么？说下你在项目中碰到的坑。 eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？ 你所知道微服务的技术栈有哪些？列举一二。 什么是微服务架构？</summary></entry><entry><title type="html">分布式锁用 Redis 还是 Zookeeper</title><link href="http://localhost:4000/docker/distributed" rel="alternate" type="text/html" title="分布式锁用 Redis 还是 Zookeeper" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>http://localhost:4000/docker/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%A8%20Redis%20%E8%BF%98%E6%98%AF%20Zookeeper</id><content type="html" xml:base="http://localhost:4000/docker/distributed">&lt;h3 id=&quot;为什么用分布式锁&quot;&gt;为什么用分布式锁？&lt;/h3&gt;

&lt;p&gt;在讨论这个问题之前，我们先来看一个业务场景：系统A是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。由于系统有一定的并发，所以会预先将商品的库存保存在redis中，用户下单的时候会更新redis的库存。此时系统架构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-873d013a21d4f1b01f6251fb7d3d44c0_1440w.jpg&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是这样一来会产生一个问题：假如某个时刻，redis里面的某个商品库存为1，此时两个请求同时到来，其中一个请求执行到上图的第3步，更新数据库的库存为0，但是第4步还没有执行。而另外一个请求执行到了第2步，发现库存还是1，就继续执行第3步。这样的结果，是导致卖出了2个商品，然而其实库存只有1个。很明显不对啊！这就是典型的库存超卖问题此时，我们很容易想到解决方案：用锁把2、3、4步锁住，让他们执行完之后，另一个线程才能进来执行第2步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-10bcf2d5309db9aecd74ff2c21497018_1440w.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;按照上面的图，在执行第2步时，使用Java提供的synchronized或者ReentrantLock来锁住，然后在第4步执行完之后才释放锁。这样一来，2、3、4 这3个步骤就被“锁”住了，多个线程之间只能串行化执行。关注公众号互联网架构师，回复关键字2T，获取最新架构视频但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-da24fb879b15402f6f900dedefae2b5c_1440w.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。为什么呢？因为上图中的两个A系统，运行在两个不同的JVM里面，他们加的锁只对属于自己JVM里面的线程有效，对于其他JVM的线程是无效的。因此，这里的问题是：Java提供的原生锁机制在多机部署场景下失效了这是因为两台机器加的锁不是同一个锁(两个锁在不同的JVM里面)。那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了，分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-422bcb831480f1aa6b635219eab10d11_1440w.jpg&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用Java原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。那么，如何实现分布式锁呢？接着往下看！&lt;/p&gt;

&lt;h3 id=&quot;基于redis实现分布式锁&quot;&gt;基于Redis实现分布式锁&lt;/h3&gt;

&lt;p&gt;上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。扩展：Redisson是如何实现分布式锁的？&lt;/p&gt;

&lt;p&gt;最常见的一种方案就是使用Redis做分布式锁使用Redis做分布式锁的思路大概是这样的：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除。具体代码是这样的：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 获取锁&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;anyLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unique_value&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;NX&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PX&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30000&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;// 释放锁：通过执行一段lua脚本&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 释放锁涉及到两条指令，这两条指令不是原子性的&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;KEYS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;del&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;KEYS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种方式有几大要点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一定要用SET key value NX PX milliseconds 命令
如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key永久存在)&lt;/li&gt;
  &lt;li&gt;value要具有唯一性
这个是为了在解锁的时候，需要验证value是和加锁的一致才删除key。
这是避免了一种情况：假设A获取了锁，过期时间30s，此时35s之后，锁已经自动释放了，A去释放锁，但是此时可能B获取了锁。A客户端就不能删除B的锁了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-d7ea289a12162d3801d98cf2dfaa0030_1440w.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了要考虑客户端要怎么实现分布式锁之外，还需要考虑redis的部署问题。redis有3种部署方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单机模式&lt;/li&gt;
  &lt;li&gt;master-slave + sentinel选举模式&lt;/li&gt;
  &lt;li&gt;redis cluster模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。基于以上的考虑，其实redis的作者也考虑到这个问题，他提出了一个RedLock的算法，这个算法的意思大概是这样的：假设redis的部署模式是redis cluster，总共有5个master节点，通过以下步骤获取一把锁：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取当前时间戳，单位是毫秒&lt;/li&gt;
  &lt;li&gt;轮流尝试在每个master节点上创建锁，过期时间设置较短，一般就几十毫秒&lt;/li&gt;
  &lt;li&gt;尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1）&lt;/li&gt;
  &lt;li&gt;客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了&lt;/li&gt;
  &lt;li&gt;要是锁建立失败了，那么就依次删除这个锁&lt;/li&gt;
  &lt;li&gt;只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁&lt;/li&gt;
  &lt;li&gt;但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-0c606f11d018368945c0efc1e3cb5de4_1440w.jpg&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;另一种方式redisson&quot;&gt;另一种方式：Redisson&lt;/h4&gt;

&lt;p&gt;此外，实现Redis的分布式锁，除了自己基于redis client原生api来实现之外，还可以使用开源框架：RedissionRedisson是一个企业级的开源Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？回想一下上面说的，如果自己写代码来通过redis设置一个值，是通过下面这个命令设置的。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SET anyLock unique_value NX PX 30000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里设置的超时时间是30s，假如我超过30s都还没有完成业务逻辑的情况下，key会过期，其他线程有可能会获取到锁。这样一来的话，第一个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看redisson是怎么实现的？先感受一下使用redission的爽：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;useClusterServers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.101:7001&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.101:7002&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.101:7003&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.102:7001&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.102:7002&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addNodeAddress&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;redis://192.168.31.102:7003&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;RedissonClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;


&lt;span class=&quot;nc&quot;&gt;RLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;anyLock&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;就是这么简单，我们只需要通过它的api中的lock和unlock即可完成分布式锁，他帮我们考虑了很多细节：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;redisson设置一个key的默认过期时间为30s,如果某个客户端持有一个锁超过了30s怎么办？&lt;/p&gt;

    &lt;p&gt;redisson中有一个watchdog的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间设为30s
这样的话，就算一直持有锁也不会出现key过期了，其他线程获取到锁的问题了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;redisson的“看门狗”逻辑保证了没有死锁发生。
(如果机器宕机了，看门狗也就没了。此时就不会延长key的过期时间，到了30s之后就会自动过期了，其他线程可以获取到锁)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-1f2f1e05c7a1d1101ac6fb53c4186f9b_1440w.jpg&quot; alt=&quot;7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里稍微贴出来其实现代码：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 加锁逻辑&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tryAcquireAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaseTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaseTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tryLockInnerAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaseTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedisCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;EVAL_LONG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 调用一段lua脚本，设置一些key、过期时间&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;RFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ttlRemainingFuture&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tryLockInnerAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConnectionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getCfg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getLockWatchdogTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedisCommands&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;EVAL_LONG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ttlRemainingFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FutureListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operationComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isSuccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ttlRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// lock acquired&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ttlRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 看门狗逻辑&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;scheduleExpirationRenewal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ttlRemainingFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;tryLockInnerAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leaseTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedisStrictCommand&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;internalLockLeaseTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaseTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;evalWriteAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LongCodec&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;INSTANCE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;&quot;if (redis.call('exists', KEYS[1]) == 0) then &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;return nil; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;&quot;end; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;&quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                  &lt;span class=&quot;s&quot;&gt;&quot;return nil; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;&quot;end; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
              &lt;span class=&quot;s&quot;&gt;&quot;return redis.call('pttl', KEYS[1]);&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;singletonList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internalLockLeaseTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLockName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 看门狗最终会调用了这里&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scheduleExpirationRenewal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expirationRenewalMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 这个任务会延迟10s执行&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Timeout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandExecutor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getConnectionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;newTimeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimerTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Timeout&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// 这个操作会将key的过期时间重新设置为30s&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;RFuture&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;renewExpirationAsync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FutureListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operationComplete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;expirationRenewalMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isSuccess&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Can't update lock &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; expiration&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getNow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;// reschedule itself&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;// 通过递归调用本方法，无限循环延长过期时间&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;scheduleExpirationRenewal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;internalLockLeaseTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MILLISECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expirationRenewalMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getEntryName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExpirationEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadId&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;另外&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;redisson还提供了对redlock算法的支持&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;它的用法也很简单&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;RedissonClient&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;RLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFairLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lock1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;RLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFairLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lock2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;RLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;redisson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getFairLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;lock3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;RedissonRedLock&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RedissonRedLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;multiLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;multiLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;unlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;小结&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;本节分析了使用redis作为分布式锁的具体落地方案以及其一些局限性然后介绍了一个redis的客户端框架redisson&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;这也是我推荐大家使用的&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;比自己写代码实现会少care很多细节&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;基于zookeeper实现分布式锁&quot;&gt;基于zookeeper实现分布式锁&lt;/h4&gt;

&lt;p&gt;常见的分布式锁实现方案里面，除了使用redis来实现之外，使用zookeeper也可以实现分布式锁。在介绍zookeeper(下文用zk代替)实现分布式锁的机制之前，先粗略介绍一下zk是什么东西：Zookeeper是一种提供配置管理、分布式协同以及命名的中心化服务。zk的模型是这样的：zk包含一系列的节点，叫做znode，就好像文件系统一样每个znode表示一个目录，然后znode有一些特性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;有序节点&lt;/strong&gt;：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；
zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号
也就是说，如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__临时节点：__客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;__事件监听：__在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zookeeper有如下四种事件：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;节点创建&lt;/li&gt;
      &lt;li&gt;节点删除&lt;/li&gt;
      &lt;li&gt;节点数据修改&lt;/li&gt;
      &lt;li&gt;子节点变更&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于以上的一些zk的特性，我们很容易得出使用zk实现分布式锁的落地方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在/lock/目录下。&lt;/li&gt;
  &lt;li&gt;创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点&lt;/li&gt;
  &lt;li&gt;如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。&lt;/li&gt;
  &lt;li&gt;如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。
比如当前线程获取到的节点序号为/lock/003,然后所有的节点列表为[/lock/001,/lock/002,/lock/003],则对/lock/002这个节点添加一个事件监听器。
如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。比如/lock/001释放了，/lock/002监听到时间，此时节点集合为[/lock/002,/lock/003],则/lock/002为最小序号节点，获取到锁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;整个过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-513fed78f8eb51568f1c392003a394a6_1440w.jpg&quot; alt=&quot;8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。&lt;/p&gt;

&lt;h4 id=&quot;curator介绍&quot;&gt;Curator介绍&lt;/h4&gt;

&lt;p&gt;Curator是一个zookeeper的开源客户端，也提供了分布式锁的实现。他的使用方式也比较简单：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;InterProcessMutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;interProcessMutex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;InterProcessMutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/anyLock&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;interProcessMutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;interProcessMutex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实现分布式锁的核心源码如下：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;internalLockLoop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;millisToWait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ourPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;haveTheLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;doDelete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;revocable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;usingWatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revocableWatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ourPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CuratorFrameworkState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;STARTED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;haveTheLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 获取当前所有节点排序后的集合&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getSortedChildren&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 获取当前节点的名称&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;              &lt;span class=&quot;n&quot;&gt;sequenceNodeName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ourPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;substring&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// +1 to include the slash&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 判断当前节点是否是最小的节点&lt;/span&gt;
            &lt;span class=&quot;nc&quot;&gt;PredicateResults&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;predicateResults&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;driver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getsTheLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sequenceNodeName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maxLeases&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicateResults&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getsTheLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 获取到锁&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;haveTheLock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 没获取到锁，对当前节点的上一个节点注册一个监听器&lt;/span&gt;
                &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;previousSequencePath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;basePath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;predicateResults&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPathToWatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;nc&quot;&gt;Stat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checkExists&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;usingWatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;watcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;previousSequencePath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;millisToWait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;millisToWait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;startMillis&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;millisToWait&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
                                &lt;span class=&quot;n&quot;&gt;doDelete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// timed out - delete our node&lt;/span&gt;
                                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;millisToWait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// else it may have been deleted (i.e. lock released). Try to acquire again&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;doDelete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doDelete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;deleteOurPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ourPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;haveTheLock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其实curator实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/distributed/0820/v2-b6efe243b1bc93569de0412dbab9b527_1440w.jpg&quot; alt=&quot;9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;小结：本节介绍了zookeeperr实现分布式锁的方案以及zk的开源客户端的基本使用，简要的介绍了其实现原理。&lt;/p&gt;

&lt;h4 id=&quot;两种方案的优缺点比较&quot;&gt;两种方案的优缺点比较&lt;/h4&gt;

&lt;p&gt;学完了两种分布式锁的实现方案之后，本节需要讨论的是redis和zk的实现方案中各自的优缺点。对于redis的分布式锁而言，它有以下缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。&lt;/li&gt;
  &lt;li&gt;另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮&lt;/li&gt;
  &lt;li&gt;即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking&lt;/li&gt;
  &lt;li&gt;redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是另一方面使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”所以使用redis作为分布式锁也不失为一种好的方案，最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。&lt;/p&gt;

&lt;p&gt;对于zk分布式锁而言:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。&lt;/li&gt;
  &lt;li&gt;如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是zk也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。&lt;/p&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结：&lt;/h4&gt;

&lt;p&gt;综上所述，redis和zookeeper都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。&lt;/p&gt;

&lt;h3 id=&quot;建议&quot;&gt;建议&lt;/h3&gt;

&lt;p&gt;通过前面的分析，实现分布式锁的两种常见方案：redis和zookeeper，他们各有千秋。应该如何选型呢？&lt;/p&gt;

&lt;p&gt;就个人而言的话，我 &lt;strong&gt;比较推崇zk实现的锁&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;因为redis是有可能存在隐患的，可能会导致数据不对的情况。但是，怎么选用要看具体在公司的场景了。&lt;/p&gt;

&lt;p&gt;如果公司里面有zk集群条件，优先选用zk实现，但是如果说公司里面只有redis集群，没有条件搭建zk集群。&lt;/p&gt;

&lt;p&gt;那么其实用redis来实现也可以，另外还可能是系统设计者考虑到了系统已经有redis，但是又不希望再次引入一些外部依赖的情况下，可以选用redis。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="distributed" /><summary type="html">为什么用分布式锁？ 在讨论这个问题之前，我们先来看一个业务场景：系统A是一个电商系统，目前是一台机器部署，系统中有一个用户下订单的接口，但是用户下订单之前一定要去检查一下库存，确保库存足够了才会给用户下单。由于系统有一定的并发，所以会预先将商品的库存保存在redis中，用户下单的时候会更新redis的库存。此时系统架构如下： 但是这样一来会产生一个问题：假如某个时刻，redis里面的某个商品库存为1，此时两个请求同时到来，其中一个请求执行到上图的第3步，更新数据库的库存为0，但是第4步还没有执行。而另外一个请求执行到了第2步，发现库存还是1，就继续执行第3步。这样的结果，是导致卖出了2个商品，然而其实库存只有1个。很明显不对啊！这就是典型的库存超卖问题此时，我们很容易想到解决方案：用锁把2、3、4步锁住，让他们执行完之后，另一个线程才能进来执行第2步。 按照上面的图，在执行第2步时，使用Java提供的synchronized或者ReentrantLock来锁住，然后在第4步执行完之后才释放锁。这样一来，2、3、4 这3个步骤就被“锁”住了，多个线程之间只能串行化执行。关注公众号互联网架构师，回复关键字2T，获取最新架构视频但是好景不长，整个系统的并发飙升，一台机器扛不住了。现在要增加一台机器，如下图： 增加机器之后，系统变成上图所示，我的天！假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。为什么呢？因为上图中的两个A系统，运行在两个不同的JVM里面，他们加的锁只对属于自己JVM里面的线程有效，对于其他JVM的线程是无效的。因此，这里的问题是：Java提供的原生锁机制在多机部署场景下失效了这是因为两台机器加的锁不是同一个锁(两个锁在不同的JVM里面)。那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁隆重登场了，分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库。文字描述不太直观，我们来看下图： 通过上面的分析，我们知道了库存超卖场景在分布式部署系统的情况下使用Java原生的锁机制无法保证线程安全，所以我们需要用到分布式锁的方案。那么，如何实现分布式锁呢？接着往下看！ 基于Redis实现分布式锁 上面分析为啥要使用分布式锁了，这里我们来具体看看分布式锁落地的时候应该怎么样处理。扩展：Redisson是如何实现分布式锁的？ 最常见的一种方案就是使用Redis做分布式锁使用Redis做分布式锁的思路大概是这样的：在redis中设置一个值表示加了锁，然后释放锁的时候就把这个key删除。具体代码是这样的： // 获取锁 // NX是指如果key不存在就成功，key存在返回false，PX可以指定过期时间 SET anyLock unique_value NX PX 30000 // 释放锁：通过执行一段lua脚本 // 释放锁涉及到两条指令，这两条指令不是原子性的 // 需要用到redis的lua脚本支持特性，redis执行lua脚本是原子性的 if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1]) else return 0 end 这种方式有几大要点： 一定要用SET key value NX PX milliseconds 命令 如果不用，先设置了值，再设置过期时间，这个不是原子性操作，有可能在设置过期时间之前宕机，会造成死锁(key永久存在) value要具有唯一性 这个是为了在解锁的时候，需要验证value是和加锁的一致才删除key。 这是避免了一种情况：假设A获取了锁，过期时间30s，此时35s之后，锁已经自动释放了，A去释放锁，但是此时可能B获取了锁。A客户端就不能删除B的锁了。 除了要考虑客户端要怎么实现分布式锁之外，还需要考虑redis的部署问题。redis有3种部署方式： 单机模式 master-slave + sentinel选举模式 redis cluster模式 使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。基于以上的考虑，其实redis的作者也考虑到这个问题，他提出了一个RedLock的算法，这个算法的意思大概是这样的：假设redis的部署模式是redis cluster，总共有5个master节点，通过以下步骤获取一把锁： 获取当前时间戳，单位是毫秒 轮流尝试在每个master节点上创建锁，过期时间设置较短，一般就几十毫秒 尝试在大多数节点上建立一个锁，比如5个节点就要求是3个节点（n / 2 +1） 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了 要是锁建立失败了，那么就依次删除这个锁 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁 但是这样的这种算法还是颇具争议的，可能还会存在不少的问题，无法保证加锁的过程一定正确。 另一种方式：Redisson 此外，实现Redis的分布式锁，除了自己基于redis client原生api来实现之外，还可以使用开源框架：RedissionRedisson是一个企业级的开源Redis Client，也提供了分布式锁的支持。我也非常推荐大家使用，为什么呢？回想一下上面说的，如果自己写代码来通过redis设置一个值，是通过下面这个命令设置的。 SET anyLock unique_value NX PX 30000 这里设置的超时时间是30s，假如我超过30s都还没有完成业务逻辑的情况下，key会过期，其他线程有可能会获取到锁。这样一来的话，第一个线程还没执行完业务逻辑，第二个线程进来了也会出现线程安全问题。所以我们还需要额外的去维护这个过期时间，太麻烦了~我们来看看redisson是怎么实现的？先感受一下使用redission的爽： Config config = new Config(); config.useClusterServers() .addNodeAddress(&quot;redis://192.168.31.101:7001&quot;) .addNodeAddress(&quot;redis://192.168.31.101:7002&quot;) .addNodeAddress(&quot;redis://192.168.31.101:7003&quot;) .addNodeAddress(&quot;redis://192.168.31.102:7001&quot;) .addNodeAddress(&quot;redis://192.168.31.102:7002&quot;) .addNodeAddress(&quot;redis://192.168.31.102:7003&quot;); RedissonClient redisson = Redisson.create(config); RLock lock = redisson.getLock(&quot;anyLock&quot;); lock.lock(); lock.unlock(); 就是这么简单，我们只需要通过它的api中的lock和unlock即可完成分布式锁，他帮我们考虑了很多细节： redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行 redisson设置一个key的默认过期时间为30s,如果某个客户端持有一个锁超过了30s怎么办？ redisson中有一个watchdog的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间设为30s 这样的话，就算一直持有锁也不会出现key过期了，其他线程获取到锁的问题了。 redisson的“看门狗”逻辑保证了没有死锁发生。 (如果机器宕机了，看门狗也就没了。此时就不会延长key的过期时间，到了30s之后就会自动过期了，其他线程可以获取到锁) 这里稍微贴出来其实现代码： // 加锁逻辑 private &amp;lt;T&amp;gt; RFuture&amp;lt;Long&amp;gt; tryAcquireAsync(long leaseTime, TimeUnit unit, final long threadId) { if (leaseTime != -1) { return tryLockInnerAsync(leaseTime, unit, threadId, RedisCommands.EVAL_LONG); } // 调用一段lua脚本，设置一些key、过期时间 RFuture&amp;lt;Long&amp;gt; ttlRemainingFuture = tryLockInnerAsync(commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG); ttlRemainingFuture.addListener(new FutureListener&amp;lt;Long&amp;gt;() { @Override public void operationComplete(Future&amp;lt;Long&amp;gt; future) throws Exception { if (!future.isSuccess()) { return; } Long ttlRemaining = future.getNow(); // lock acquired if (ttlRemaining == null) { // 看门狗逻辑 scheduleExpirationRenewal(threadId); } } }); return ttlRemainingFuture; } &amp;lt;T&amp;gt; RFuture&amp;lt;T&amp;gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&amp;lt;T&amp;gt; command) { internalLockLeaseTime = unit.toMillis(leaseTime); return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command, &quot;if (redis.call('exists', KEYS[1]) == 0) then &quot; + &quot;redis.call('hset', KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + &quot;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then &quot; + &quot;redis.call('hincrby', KEYS[1], ARGV[2], 1); &quot; + &quot;redis.call('pexpire', KEYS[1], ARGV[1]); &quot; + &quot;return nil; &quot; + &quot;end; &quot; + &quot;return redis.call('pttl', KEYS[1]);&quot;, Collections.&amp;lt;Object&amp;gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId)); } // 看门狗最终会调用了这里 private void scheduleExpirationRenewal(final long threadId) { if (expirationRenewalMap.containsKey(getEntryName())) { return; } // 这个任务会延迟10s执行 Timeout task = commandExecutor.getConnectionManager().newTimeout(new TimerTask() { @Override public void run(Timeout timeout) throws Exception { // 这个操作会将key的过期时间重新设置为30s RFuture&amp;lt;Boolean&amp;gt; future = renewExpirationAsync(threadId); future.addListener(new FutureListener&amp;lt;Boolean&amp;gt;() { @Override public void operationComplete(Future&amp;lt;Boolean&amp;gt; future) throws Exception { expirationRenewalMap.remove(getEntryName()); if (!future.isSuccess()) { log.error(&quot;Can't update lock &quot; + getName() + &quot; expiration&quot;, future.cause()); return; } if (future.getNow()) { // reschedule itself // 通过递归调用本方法，无限循环延长过期时间 scheduleExpirationRenewal(threadId); } } }); } }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS); if (expirationRenewalMap.putIfAbsent(getEntryName(), new ExpirationEntry(threadId, task)) != null) { task.cancel(); } } 另外，redisson还提供了对redlock算法的支持,它的用法也很简单： RedissonClient redisson = Redisson.create(config); RLock lock1 = redisson.getFairLock(&quot;lock1&quot;); RLock lock2 = redisson.getFairLock(&quot;lock2&quot;); RLock lock3 = redisson.getFairLock(&quot;lock3&quot;); RedissonRedLock multiLock = new RedissonRedLock(lock1, lock2, lock3); multiLock.lock(); multiLock.unlock(); 小结： 本节分析了使用redis作为分布式锁的具体落地方案以及其一些局限性然后介绍了一个redis的客户端框架redisson，这也是我推荐大家使用的，比自己写代码实现会少care很多细节。 基于zookeeper实现分布式锁 常见的分布式锁实现方案里面，除了使用redis来实现之外，使用zookeeper也可以实现分布式锁。在介绍zookeeper(下文用zk代替)实现分布式锁的机制之前，先粗略介绍一下zk是什么东西：Zookeeper是一种提供配置管理、分布式协同以及命名的中心化服务。zk的模型是这样的：zk包含一系列的节点，叫做znode，就好像文件系统一样每个znode表示一个目录，然后znode有一些特性： 有序节点：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点； zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号 也就是说，如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。 __临时节点：__客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。 __事件监听：__在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前 zookeeper有如下四种事件： 节点创建 节点删除 节点数据修改 子节点变更 基于以上的一些zk的特性，我们很容易得出使用zk实现分布式锁的落地方案： 使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在/lock/目录下。 创建节点成功后，获取/lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点 如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。 如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。 比如当前线程获取到的节点序号为/lock/003,然后所有的节点列表为[/lock/001,/lock/002,/lock/003],则对/lock/002这个节点添加一个事件监听器。 如果锁释放了，会唤醒下一个序号的节点，然后重新执行第3步，判断是否自己的节点序号是最小。比如/lock/001释放了，/lock/002监听到时间，此时节点集合为[/lock/002,/lock/003],则/lock/002为最小序号节点，获取到锁。 整个过程如下： 具体的实现思路就是这样，至于代码怎么写，这里比较复杂就不贴出来了。 Curator介绍 Curator是一个zookeeper的开源客户端，也提供了分布式锁的实现。他的使用方式也比较简单： InterProcessMutex interProcessMutex = new InterProcessMutex(client,&quot;/anyLock&quot;); interProcessMutex.acquire(); interProcessMutex.release(); 其实现分布式锁的核心源码如下： private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception { boolean haveTheLock = false; boolean doDelete = false; try { if ( revocable.get() != null ) { client.getData().usingWatcher(revocableWatcher).forPath(ourPath); } while ( (client.getState() == CuratorFrameworkState.STARTED) &amp;amp;&amp;amp; !haveTheLock ) { // 获取当前所有节点排序后的集合 List&amp;lt;String&amp;gt; children = getSortedChildren(); // 获取当前节点的名称 String sequenceNodeName = ourPath.substring(basePath.length() + 1); // +1 to include the slash // 判断当前节点是否是最小的节点 PredicateResults predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases); if ( predicateResults.getsTheLock() ) { // 获取到锁 haveTheLock = true; } else { // 没获取到锁，对当前节点的上一个节点注册一个监听器 String previousSequencePath = basePath + &quot;/&quot; + predicateResults.getPathToWatch(); synchronized(this){ Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath); if ( stat != null ){ if ( millisToWait != null ){ millisToWait -= (System.currentTimeMillis() - startMillis); startMillis = System.currentTimeMillis(); if ( millisToWait &amp;lt;= 0 ){ doDelete = true; // timed out - delete our node break; } wait(millisToWait); }else{ wait(); } } } // else it may have been deleted (i.e. lock released). Try to acquire again } } } catch ( Exception e ) { doDelete = true; throw e; } finally{ if ( doDelete ){ deleteOurPath(ourPath); } } return haveTheLock; } 其实curator实现分布式锁的底层原理和上面分析的是差不多的。这里我们用一张图详细描述其原理： 小结：本节介绍了zookeeperr实现分布式锁的方案以及zk的开源客户端的基本使用，简要的介绍了其实现原理。 两种方案的优缺点比较 学完了两种分布式锁的实现方案之后，本节需要讨论的是redis和zk的实现方案中各自的优缺点。对于redis的分布式锁而言，它有以下缺点： 它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。 另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮 即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能。 但是另一方面使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”所以使用redis作为分布式锁也不失为一种好的方案，最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。 对于zk分布式锁而言: zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。 如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。 但是zk也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。 小结： 综上所述，redis和zookeeper都有其优缺点。我们在做技术选型的时候可以根据这些问题作为参考因素。 建议 通过前面的分析，实现分布式锁的两种常见方案：redis和zookeeper，他们各有千秋。应该如何选型呢？ 就个人而言的话，我 比较推崇zk实现的锁： 因为redis是有可能存在隐患的，可能会导致数据不对的情况。但是，怎么选用要看具体在公司的场景了。 如果公司里面有zk集群条件，优先选用zk实现，但是如果说公司里面只有redis集群，没有条件搭建zk集群。 那么其实用redis来实现也可以，另外还可能是系统设计者考虑到了系统已经有redis，但是又不希望再次引入一些外部依赖的情况下，可以选用redis。</summary></entry><entry><title type="html">栈溢出(stackoverflow)的原因及解决办法</title><link href="http://localhost:4000/jvm/stackoverflow" rel="alternate" type="text/html" title="栈溢出(stackoverflow)的原因及解决办法" /><published>2020-08-20T00:00:00+08:00</published><updated>2020-08-20T00:00:00+08:00</updated><id>http://localhost:4000/jvm/%E6%A0%88%E6%BA%A2%E5%87%BA(stackoverflow)%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/jvm/stackoverflow">&lt;p&gt;__栈溢出(stackoverflow)__的原因及解决办法：程序功能大概有网络通信、数据库、绘图等。测试的时候程序一运行到某个函数就出现此错误，查了很多地方，试了很多解决办法，终于把问题解决了。
大家都知道,Windows程序的内存机制大概是这样的:
全局变量(局部的静态变量本质也属于此范围)存储于堆内存,该段内存较大,一般不会溢出;
函数地址、函数参数、局部变量等信息存储于栈内存;
程序中栈内存默认大小为1M,对于当前日益扩大的程序规模而言,稍有不慎就可能出问题。(动态申请的内存即new出来的内存不在栈中)即如果函数这样写&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;voidtest_stack_overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chdata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chdata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;是不会出现这个错误的，而这样写则不行：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;voidtest_stack_overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;charchdata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;大多数情况下都会出现内存溢出的错误。出现__栈内存溢出的常见原因有2个__：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。&lt;/li&gt;
  &lt;li&gt;局部静态变量体积太大&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用(反正我是这么做的),所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的,这个我没试过但我想没有谁会把调用深度作那么多。&lt;/p&gt;

&lt;p&gt;检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处,然后按下快捷键Alt+7调出callstack窗口,在窗口中可以看到函数调用的层次关系。&lt;/p&gt;

&lt;p&gt;第二种情况比较常见了,我就是犯了这个错误,我在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组,大概是1.5M。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法大致说来也有两种&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;增加栈内存的数目&lt;/li&gt;
  &lt;li&gt;使用堆内存增加栈内存方法如下,在程序中依次选择Project-&amp;gt;Setting-&amp;gt;Link,在Category中选择output,在Reserve中输入16进制的栈内存大小如:0x10000000，然后点ok就可以了。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其他编译器也有类似的设置,个人认为这不是一个好办法,有一个致命原因,不知道有没有人遇到过,我把栈内存改大后,与数据库建立不了连接了(ADO方式,Acess数据库),把栈内存还原,问题立刻消失。不知道究竟是什么原因，有知道的可以告诉我。&lt;/p&gt;

&lt;p&gt;第二种解决办法是比较可行的,具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)。即可以把上例中的函数这么写：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;voidtest_stack_overflow&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;staticcharchdata&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然,除非万不得已,尽量不要使用这么大的数组，出现这种情况多半说明程序结构有问题。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="jvm" /><summary type="html">__栈溢出(stackoverflow)__的原因及解决办法：程序功能大概有网络通信、数据库、绘图等。测试的时候程序一运行到某个函数就出现此错误，查了很多地方，试了很多解决办法，终于把问题解决了。 大家都知道,Windows程序的内存机制大概是这样的: 全局变量(局部的静态变量本质也属于此范围)存储于堆内存,该段内存较大,一般不会溢出; 函数地址、函数参数、局部变量等信息存储于栈内存; 程序中栈内存默认大小为1M,对于当前日益扩大的程序规模而言,稍有不慎就可能出问题。(动态申请的内存即new出来的内存不在栈中)即如果函数这样写 voidtest_stack_overflow(){ char\*chdata=new[2\*1024\*1024]; delete[]chdata; } 是不会出现这个错误的，而这样写则不行： voidtest_stack_overflow(){ charchdata[2\*1024\*1024]; } 大多数情况下都会出现内存溢出的错误。出现__栈内存溢出的常见原因有2个__： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。 局部静态变量体积太大 第一种情况不太常见,因为很多情况下我们都用其他方法来代替递归调用(反正我是这么做的),所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的,这个我没试过但我想没有谁会把调用深度作那么多。 检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处,然后按下快捷键Alt+7调出callstack窗口,在窗口中可以看到函数调用的层次关系。 第二种情况比较常见了,我就是犯了这个错误,我在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组,大概是1.5M。 解决办法大致说来也有两种： 增加栈内存的数目 使用堆内存增加栈内存方法如下,在程序中依次选择Project-&amp;gt;Setting-&amp;gt;Link,在Category中选择output,在Reserve中输入16进制的栈内存大小如:0x10000000，然后点ok就可以了。 其他编译器也有类似的设置,个人认为这不是一个好办法,有一个致命原因,不知道有没有人遇到过,我把栈内存改大后,与数据库建立不了连接了(ADO方式,Acess数据库),把栈内存还原,问题立刻消失。不知道究竟是什么原因，有知道的可以告诉我。 第二种解决办法是比较可行的,具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)。即可以把上例中的函数这么写： voidtest_stack_overflow(){ staticcharchdata[2\*1024\*1024]; } 当然,除非万不得已,尽量不要使用这么大的数组，出现这种情况多半说明程序结构有问题。</summary></entry><entry><title type="html">java内存泄漏与内存溢出</title><link href="http://localhost:4000/jvm/outofmemory" rel="alternate" type="text/html" title="java内存泄漏与内存溢出" /><published>2020-08-19T00:00:00+08:00</published><updated>2020-08-19T00:00:00+08:00</updated><id>http://localhost:4000/jvm/java%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA</id><content type="html" xml:base="http://localhost:4000/jvm/outofmemory">&lt;p&gt;内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；&lt;/p&gt;

&lt;p&gt;内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。&lt;/p&gt;

&lt;p&gt;memory leak会最终会导致out of memory！&lt;/p&gt;

&lt;p&gt;以发生的方式来分类，内存泄漏可以分为4类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。&lt;/li&gt;
  &lt;li&gt;偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。&lt;/li&gt;
  &lt;li&gt;一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。&lt;/li&gt;
  &lt;li&gt;隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到&lt;/p&gt;

&lt;h4 id=&quot;一java内存回收机制&quot;&gt;一、Java内存回收机制&lt;/h4&gt;
&lt;p&gt;不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，&lt;/p&gt;

&lt;h4 id=&quot;二java内存泄露引起原因&quot;&gt;二、Java内存泄露引起原因&lt;/h4&gt;
&lt;p&gt;内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。&lt;/p&gt;

&lt;p&gt;那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类：&lt;/p&gt;
&lt;h5 id=&quot;1静态集合类引起内存泄露&quot;&gt;1、静态集合类引起内存泄露：&lt;/h5&gt;
&lt;p&gt;像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Static Vector v = new Vector(10);
for (int i = 1; i&amp;lt;100; i++)
{
  Object o = new Object();
  v.add(o);
  o = null;
}//
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。&lt;/p&gt;

&lt;h5 id=&quot;2当集合里面的对象属性被修改后再调用remove方法时不起作用&quot;&gt;2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;唐僧&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pwd1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;孙悟空&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pwd2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;猪八戒&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pwd3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;总共有:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; 个元素!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//结果：总共有:3 个元素!&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//修改p3的年龄,此时p3元素对应的hashcode值发生改变&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//此时remove不掉，造成内存泄漏&lt;/span&gt;

  &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//重新添加，居然添加成功&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;总共有:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; 个元素!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//结果：总共有:4 个元素!&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h5 id=&quot;3监听器&quot;&gt;3、监听器&lt;/h5&gt;
&lt;p&gt;在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。&lt;/p&gt;

&lt;h5 id=&quot;4各种连接&quot;&gt;4、各种连接&lt;/h5&gt;
&lt;p&gt;比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。&lt;/p&gt;

&lt;h5 id=&quot;5单例模式&quot;&gt;5、单例模式&lt;/h5&gt;

&lt;p&gt;如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。&lt;/p&gt;

&lt;p&gt;如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露&lt;/p&gt;

&lt;p&gt;不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//B类采用单例模式&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//getter...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="jvm" /><summary type="html">内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory； 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。 memory leak会最终会导致out of memory！ 以发生的方式来分类，内存泄漏可以分为4类： 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 一、Java内存回收机制 不论哪种语言的内存分配方式，都需要返回所分配内存的真实地址，也就是返回一个指针到内存块的首地址。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收， 二、Java内存泄露引起原因 内存泄露是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时释放，从而造成的内存空间的浪费称为内存泄露。内存泄露有时不严重且不易察觉，这样开发者就不知道存在内存泄露，但有时也会很严重，会提示你Out of memory。 那么，Java内存泄露根本原因是什么呢？长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景。具体主要有如下几大类： 1、静态集合类引起内存泄露： 像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 Static Vector v = new Vector(10); for (int i = 1; i&amp;lt;100; i++) { Object o = new Object(); v.add(o); o = null; }// 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。 2、当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。 public static void main(String[] args) { Set&amp;lt;Person&amp;gt; set = new HashSet&amp;lt;Person&amp;gt;(); Person p1 = new Person(&quot;唐僧&quot;,&quot;pwd1&quot;,25); Person p2 = new Person(&quot;孙悟空&quot;,&quot;pwd2&quot;,26); Person p3 = new Person(&quot;猪八戒&quot;,&quot;pwd3&quot;,27); set.add(p1); set.add(p2); set.add(p3); System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:3 个元素! p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 set.remove(p3); //此时remove不掉，造成内存泄漏 set.add(p3); //重新添加，居然添加成功 System.out.println(&quot;总共有:&quot;+set.size()+&quot; 个元素!&quot;); //结果：总共有:4 个元素! for (Person person : set) { System.out.println(person); } } 3、监听器 在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。 4、各种连接 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。这种情况下一般都会在try里面去的连接，在finally里面释放连接。 5、单例模式 如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露。 如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露 不正确使用单例模式是引起内存泄露的一个常见问题，单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露，考虑下面的例子： class A{ public A(){ B.getInstance().setA(this); } .... } //B类采用单例模式 class B{ private A a; private static B instance=new B(); public B(){} public static B getInstance(){ return instance; } public void setA(A a){ this.a=a; } //getter... } 显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况</summary></entry><entry><title type="html">蚂蚁集团面试题</title><link href="http://localhost:4000/mianshi/0818/01" rel="alternate" type="text/html" title="蚂蚁集团面试题" /><published>2020-08-18T00:00:00+08:00</published><updated>2020-08-18T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/0818/%E8%9A%82%E8%9A%81%E9%9B%86%E5%9B%A2</id><content type="html" xml:base="http://localhost:4000/mianshi/0818/01">&lt;h2 id=&quot;1-dubbo&quot;&gt;1 Dubbo&lt;/h2&gt;

&lt;h4 id=&quot;11-服务调用超时问题怎么解决&quot;&gt;1.1 服务调用超时问题怎么解决？&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ASPNET2008/p/7292472.html&quot;&gt;dubbo源码分析（二）：超时原理以及应用场景&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;12-dubbo支持哪些序列化方式&quot;&gt;1.2 Dubbo支持哪些序列化方式？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Hessian 序列化：是修改过的 hessian lite，默认启用&lt;/li&gt;
  &lt;li&gt;json 序列化：使用 FastJson 库&lt;/li&gt;
  &lt;li&gt;java 序列化：JDK 提供的序列化，性能不理想&lt;/li&gt;
  &lt;li&gt;dubbo 序列化：未成熟的高效 java 序列化实现，不建议在生产环境使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;13--dubbo和springcloud的关系&quot;&gt;1.3  Dubbo和SpringCloud的关系？&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;dubbo&lt;/th&gt;
      &lt;th&gt;springcloud&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;消费者，生产者，注册中心，管理中心&lt;/td&gt;
      &lt;td&gt;消费者，生产者，注册中心，管理中心，短路器，分布式配置，消息总线，服务追踪&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC&lt;/td&gt;
      &lt;td&gt;基于Http协议+rest接口调用远程请求，相对来说，Http请求会有更大的报文，占的带宽也会更多。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dubbo类似组装机，开发相对复杂&lt;/td&gt;
      &lt;td&gt;springcloud类似一体机，一站式开发，相对简单&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;14-dubbo的架构设计一共划分了哪些层&quot;&gt;1.4 Dubbo的架构设计？一共划分了哪些层？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;服务接口层(Service)：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现&lt;/li&gt;
  &lt;li&gt;配置层(Config)：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心&lt;/li&gt;
  &lt;li&gt;服务代理层(Proxy)：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton&lt;/li&gt;
  &lt;li&gt;服务注册层(Registry)：封装服务地址的注册与发现，以服务 URL 为中心&lt;/li&gt;
  &lt;li&gt;集群层(Cluster)：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心&lt;/li&gt;
  &lt;li&gt;监控层(Monitor)：RPC 调用次数和调用时间监控&lt;/li&gt;
  &lt;li&gt;远程调用层(Protocol)：封将 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocol、Invoker、Exporter&lt;/li&gt;
  &lt;li&gt;信息交换层(Exchange)：封装请求响应模式，同步转异步，以 Request 和 Response 为中心&lt;/li&gt;
  &lt;li&gt;网络传输层(Transport)：抽象 mina 和 netty 为统一接口，以 Message 为中心&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;15--dubbo的默认集群容错方案&quot;&gt;1.5  Dubbo的默认集群容错方案？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Failover Cluster，失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failfast Cluster，快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failsafe Cluster，失败安全，出现异常时，直接忽略。通常用于写入日志等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Failback Cluster，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Forking Cluster，并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks 来设置最大并行数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Broadcast Cluster，广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存本地资源信息。&lt;/p&gt;

    &lt;p&gt;默认 Failover Cluster&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1.6 Dubbo使用的是什么通信框架?&lt;/p&gt;

&lt;p&gt;1.7 Dubbo的主要应用场景？&lt;/p&gt;

&lt;p&gt;1.8 Dubbo服务注册与发现的流程？流程说明。&lt;/p&gt;

&lt;p&gt;1.9 Dubbo的集群容错方案有哪些？&lt;/p&gt;

&lt;p&gt;1.10 Dubbo的四大组件&lt;/p&gt;

&lt;p&gt;1.11 Dubbo在安全机制方面是如何解决的&lt;/p&gt;

&lt;p&gt;1.12 Dubbo和SpringCloud的区别？&lt;/p&gt;

&lt;p&gt;1.13 Dubbo支持哪些协议，每种协议的应用场景，优缺点？&lt;/p&gt;

&lt;p&gt;1.14 Dubbo的核心功能有哪些？&lt;/p&gt;

&lt;p&gt;1.15 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？&lt;/p&gt;

&lt;p&gt;1.16 Dubbo集群的负载均衡有哪些策略&lt;/p&gt;

&lt;p&gt;1.17 为什么需要服务治理？&lt;/p&gt;

&lt;p&gt;1.18 Dubbo超时时间怎样设置？&lt;/p&gt;

&lt;h2 id=&quot;2-elasticsearch&quot;&gt;2 ElasticSearch&lt;/h2&gt;

&lt;p&gt;2.1 你们公司的ES集群，一个node一般会分配几个分片？&lt;/p&gt;

&lt;p&gt;2.2 Elasticsearch是如何实现Master选举的？&lt;/p&gt;

&lt;p&gt;2.3 你是如何做写入调优的？&lt;/p&gt;

&lt;p&gt;2.4 如何避免脑裂？&lt;/p&gt;

&lt;p&gt;2.5 Elasticsearch对于大数据量（上亿量级）的聚合如何实现？&lt;/p&gt;

&lt;p&gt;2.6 ES主分片数量可以在后期更改吗？为什么？&lt;/p&gt;

&lt;p&gt;2.7 如何监控集群状态？&lt;/p&gt;

&lt;p&gt;2.8 ElasticSearch中的副本是什么？&lt;/p&gt;

&lt;p&gt;2.9 ES更新数据的执行流程？&lt;/p&gt;

&lt;p&gt;2.10 shard里面是什么组成的？&lt;/p&gt;

&lt;p&gt;2.11 ElasticSearch中的分析器是什么？&lt;/p&gt;

&lt;p&gt;2.12 什么是脑裂？&lt;/p&gt;

&lt;p&gt;2.13 客户端在和集群连接时，如何选择特定的节点执行请求的？&lt;/p&gt;

&lt;p&gt;2.14 Elasticsearch中的倒排索引是什么？&lt;/p&gt;

&lt;p&gt;2.15 什么是索引？索引（名词） 一个索引(index)&lt;/p&gt;

&lt;p&gt;2.16 详细描述一下Elasticsearch更新和删除文档的过程&lt;/p&gt;

&lt;h2 id=&quot;3-jvm&quot;&gt;3 JVM&lt;/h2&gt;

&lt;h4 id=&quot;31--jvm参数主要有种分类&quot;&gt;3.1  JVM参数主要有⼏种分类&lt;/h4&gt;

&lt;p&gt;IBM 微软的 hotpot&lt;/p&gt;

&lt;h4 id=&quot;32--java中会存在内存泄漏吗简述一下&quot;&gt;3.2  Java中会存在内存泄漏吗，简述一下。&lt;/h4&gt;

&lt;p&gt;会出现内存泄漏，当垃圾回收器清理内存后，现有内存使用量+申请新增内存&amp;gt;最大使用内存时，会出现内存泄漏&lt;/p&gt;

&lt;p&gt;主要场景包括以下两种&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;机器内存不够用&lt;/li&gt;
  &lt;li&gt;内存分配不合理&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;33--java虚拟机是如何判定两个java类是相同的&quot;&gt;3.3  Java虚拟机是如何判定两个Java类是相同的？&lt;/h4&gt;

&lt;p&gt;在新建对象的过程中，需要新通过类加载，而在类加载中通过 &lt;strong&gt;双亲委派机制&lt;/strong&gt; 来判断两个类是否相同&lt;/p&gt;

&lt;p&gt;当某个加载器需要加载某个.class 文件时，他首先把这个任务委托过他的上一级加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。&lt;/p&gt;

&lt;p&gt;下面是类加载的过程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;用于自定义类加载器 –&amp;gt; 系统类加载器 –&amp;gt; 扩展类加载 –&amp;gt; 启动类加载&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;34--java-中都有哪些引用类型&quot;&gt;3.4  Java 中都有哪些引用类型&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;__强引用（strongreference）__就是指在程序代码之中普遍存在的,类似“Object obj=new Object()” 这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象实例。&lt;/li&gt;
  &lt;li&gt;__软引用（softreference）__是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象, 在系统将要发生内存溢出异常之前,将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存,才会抛出内存溢出异常。在 JDK 1.2 之后,提供了 SoftReference 类来实现软引用。&lt;/li&gt;
  &lt;li&gt;__弱引用（weakreference）__也是用来描述非必需对象的,但是它的强度比软引用更弱一些,被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时, 无论当前内存是否足够,都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之 后,提供了 WeakReference 类来实现弱引用。&lt;/li&gt;
  &lt;li&gt;__虚引用（phantomreference）__也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象 实例是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用 来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象 实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后,提供了 PhantomReference 类来实现虚引用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;35--在-java-中对象什么时候可以被垃圾回收&quot;&gt;3.5  在 Java 中，对象什么时候可以被垃圾回收？&lt;/h4&gt;

&lt;p&gt;当对象被判定已经“死去”时，对象可以被垃圾回收，判断对象是否存活可通过以下算法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;__引用计数算法：__通过引用计数器，当被引用+1，当失去引用-1，计数为零的引用被清理&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可达性分析算法：&lt;/strong&gt; 通过跟对象作为起始点，从这个节点开始向下搜索，搜索过程所走的路径称为“引用链”，如果某个对象的到 __GC Roots __间没有连接，则说明该对象不能再被引用&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;36--stackoverflow异常有没有遇到过一般你猜测会在什么情况下被触发&quot;&gt;3.6  StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？&lt;/h4&gt;

&lt;p&gt;栈内存溢出。栈内存保存的信息包括：函数地址、函数参数、局部变量等&lt;/p&gt;

&lt;p&gt;出现__栈内存溢出的常见原因有2个__：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈&lt;/li&gt;
  &lt;li&gt;局部静态变量体积太大&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;解决办法大致说来也有两种&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;增加栈内存的数目&lt;/li&gt;
  &lt;li&gt;使用堆内存增加栈内存方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;37--堆空间分哪些部分以及如何设置各个部分&quot;&gt;3.7  堆空间分哪些部分？以及如何设置各个部分？&lt;/h4&gt;

&lt;p&gt;新生代，老年代&lt;/p&gt;

&lt;p&gt;其中新生代，分为 伊甸，to，from 按照 8:1:1 的比例进行分割&lt;/p&gt;

&lt;h4 id=&quot;38--什么是栈帧栈帧存储了什么&quot;&gt;3.8  什么是栈帧？栈帧存储了什么？&lt;/h4&gt;

&lt;p&gt;栈帧是方法运行期最重要的基本数据结构&lt;/p&gt;

&lt;p&gt;存储包括：局部变量表，操作数栈，动态连接和方法返回地址&lt;/p&gt;

&lt;h4 id=&quot;39--如何设置参数生成gc日志&quot;&gt;3.9  如何设置参数生成GC日志？&lt;/h4&gt;

&lt;p&gt;-XX:+PrintGC&lt;/p&gt;

&lt;h4 id=&quot;310--gc-是什么为什么要有-gc&quot;&gt;3.10  GC 是什么？为什么要有 GC？&lt;/h4&gt;

&lt;p&gt;Garbage Collection 垃圾回收系统，&lt;/p&gt;

&lt;p&gt;java提供的gc功能可以自动检测对象是否超出通过垃圾回收系统，由系统自动触发垃圾回收。java没有提供释放垃圾已分配内存的显示操作方法&lt;/p&gt;

&lt;h4 id=&quot;312--使用过哪些jdk命令并说明各个的作用是什么&quot;&gt;3.12  使用过哪些jdk命令，并说明各个的作用是什么&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;jps：__用于显示__指定系统内所有HotSpot虚拟机进程&lt;/strong&gt;，并且能显示虚拟机执行主类以及本地虚拟机唯一ID&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jstat：__用于__监视虚拟机各种运行状态信息的工具&lt;/strong&gt;，可以显示本地或者远程的虚拟机进程类装载、内存、GC、JIT等运行数据，在没有GUI图像界面的服务器上，&lt;strong&gt;主要就是用它在运行期定位性能问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jmap：__用于生成堆转储快照(heapdump或dump文件)，说白了就是把java堆使用情况快照一份导出来供我们查看，__用来排查问题&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;__jhat：__这个就是和jmap搭配使用的，jmap导出来的堆快照文件用jhat 打开分析&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;jstack：__用于生成虚拟机当前时刻线程快照(threaddump或javacore)。__主要用来定位线程出现长时间停顿的原因，判断死锁啊，死循环的等&lt;/strong&gt;。通过jstack就可知各线程的调用堆栈情况&lt;/p&gt;

&lt;p&gt;__jinfo：__用来查看和调整虚拟机各项参数使用格式&lt;/p&gt;

&lt;h4 id=&quot;313--jvm运行时数据区区域分为哪部分&quot;&gt;3.13  JVM运行时数据区区域分为哪⼏部分？&lt;/h4&gt;

&lt;p&gt;堆，方法区，本地方法区，计数器，栈&lt;/p&gt;

&lt;h4 id=&quot;314--是否了解类加载器双亲委派模型机制和破坏双亲委派模型&quot;&gt;3.14  是否了解类加载器双亲委派模型机制和破坏双亲委派模型？&lt;/h4&gt;

&lt;p&gt;在类加载的过程中，会用到双亲委派机制，目的是为了保障.class 文件的唯一性，&lt;/p&gt;

&lt;p&gt;他首先把这个任务委托过他的上一级加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。&lt;/p&gt;

&lt;p&gt;双亲委派机制中类加载过程：自定义类加载器，程序类加载器，扩展类加载，系统类加载器&lt;/p&gt;

&lt;p&gt;破坏双亲委派机制：通过继承 ClassLoader 并重写loadclass&lt;/p&gt;

&lt;h4 id=&quot;315--逃逸分析有几种类型&quot;&gt;3.15  逃逸分析有几种类型？&lt;/h4&gt;

&lt;p&gt;方法逃逸：对象的方法被外部方法所引用&lt;/p&gt;

&lt;p&gt;线程逃逸：方法被外部线程访问到&lt;/p&gt;

&lt;h4 id=&quot;316---xms这些参数的含义是什么&quot;&gt;3.16  -Xms这些参数的含义是什么？&lt;/h4&gt;

&lt;p&gt;设置堆内存&lt;/p&gt;

&lt;h4 id=&quot;317--你知道哪几种垃圾收集器各自的优缺点重点讲下cms和g1包括原理流程优缺点&quot;&gt;3.17  你知道哪几种垃圾收集器,各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。&lt;/h4&gt;

&lt;h4 id=&quot;318--jvm的内存结构eden和survivor比例是多少&quot;&gt;3.18  JVM的内存结构，Eden和Survivor比例是多少？&lt;/h4&gt;

&lt;p&gt;8:1:1&lt;/p&gt;

&lt;h2 id=&quot;4-多线程高并发&quot;&gt;4 多线程/高并发&lt;/h2&gt;

&lt;h4 id=&quot;41--负载平衡的意义什么&quot;&gt;4.1  负载平衡的意义什么？&lt;/h4&gt;

&lt;p&gt;提高硬件的使用率，提升系统的容量&lt;/p&gt;

&lt;h4 id=&quot;42--请说出同步线程及线程调度相关的方法&quot;&gt;4.2  请说出同步线程及线程调度相关的方法？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;线程调度相关方法&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;yield()：线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。若队列中没有同优先级的线程，忽略此方法。&lt;/p&gt;

&lt;p&gt;join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，低优先级的线程也可以获得执行&lt;/p&gt;

&lt;p&gt;sleep(long millis)(毫秒) ： 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。&lt;/p&gt;

&lt;p&gt;isAlive()：判断线程是否还活着&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程同步：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;synchronized 同步代码快，同步方法&lt;/p&gt;

&lt;h4 id=&quot;43--关于epoll和select的区别哪些说法-是正确的多选&quot;&gt;4.3  关于epoll和select的区别，哪些说法 是正确的？（多选）&lt;/h4&gt;
&lt;p&gt;A. epoll 和 select 都是 I/O 多路复用的技术，都可以实现同时监听 多个I/O事件的状态。
B. epoll 相比 select 效率更高，主要是基于其操作系统支持的 I/O 事件通知机制，而select是基于轮询机制。
C. epoll支持水平触发和边沿触发两种模式。
D. select能并行支持I/O比较小，且无法修改。&lt;/p&gt;

&lt;h4 id=&quot;44--启动一个线程是调用run方法还是start方法&quot;&gt;4.4  启动一个线程是调用run()方法还是start()方法？&lt;/h4&gt;

&lt;p&gt;run() 方法，start() 中饱含 run() 方法&lt;/p&gt;

&lt;h4 id=&quot;45--如何确保n个线程可以访问n个资源同时又不导致死锁&quot;&gt;4.5  如何确保N个线程可以访问N个资源同时又不导致死锁？&lt;/h4&gt;

&lt;p&gt;多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件&lt;/p&gt;

&lt;h4 id=&quot;46--编写多线程程序的几种实现方式换个问法创建多线程的方式&quot;&gt;4.6  编写多线程程序的几种实现方式（换个问法：创建多线程的方式）？&lt;/h4&gt;

&lt;p&gt;继承 Thread 重写run函数&lt;/p&gt;

&lt;p&gt;实现Runnable 重写run函数&lt;/p&gt;

&lt;p&gt;实现Callable接口，重写call函数&lt;/p&gt;

&lt;h4 id=&quot;47--线程和进程的区别&quot;&gt;4.7  线程和进程的区别？&lt;/h4&gt;

&lt;p&gt;线程是进程执行程序的最小单元&lt;/p&gt;

&lt;p&gt;进程：一个程序一个进程&lt;/p&gt;

&lt;p&gt;线程：一个进程包含多个线程&lt;/p&gt;

&lt;h4 id=&quot;48--什么是线程池有哪些常用线程池&quot;&gt;4.8  什么是线程池，有哪些常用线程池？&lt;/h4&gt;

&lt;p&gt;若干个线程放入同一个容器中，使用的时候从池中获取而不用自行创建，使用完毕不需 要销毁线程而是放回池中， 从而减少创建和销毁线程对象的开销&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用线程池：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;__newSingleThreadExecutor： __创建一个单线程的线程池， 此线程池保证所有任务的执行顺序按照任务的 提交顺序执行。&lt;/p&gt;

&lt;p&gt;__newFixedThreadPool： __创建固定大小的线程池， 每次提交一个任务就创建一个线程， 直到线程达到线 程池的最大大小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;newCachedThreadPool：&lt;/strong&gt; 创建一个可缓存的线程池， 此线程池不会对线程池大小做限制， 线程池大小 完全依赖于操作系统（或者说 JVM） 能够创建的最大线程大小。&lt;/p&gt;

&lt;p&gt;__newScheduledThreadPool： __创建一个大小无限的线程池， 此线程池支持定时以及周期性执行任务的需 求。&lt;/p&gt;

&lt;p&gt;__newSingleThreadExecutor： __创建一个单线程的线程池。 此线程池支持定时以及周期性执行任务的需 求&lt;/p&gt;

&lt;h4 id=&quot;49--什么是死锁&quot;&gt;4.9  什么是死锁？&lt;/h4&gt;

&lt;p&gt;是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进&lt;/p&gt;

&lt;p&gt;多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可&lt;/p&gt;

&lt;h4 id=&quot;410--怎么保证缓存和数据库数据的一致性&quot;&gt;4.10  怎么保证缓存和数据库数据的一致性？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Cache aside （旁路缓存 ）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是最常用最常用的pattern了。其具体逻辑如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;失效：&lt;/strong&gt;应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;命中：&lt;/strong&gt;应用程序从cache中取数据，取到后返回。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;更新：&lt;/strong&gt;先把数据存到数据库中，成功后，&lt;strong&gt;再让缓存失效&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。&lt;/p&gt;

&lt;p&gt;一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。&lt;/p&gt;

&lt;p&gt;这是标准的design pattern，包括Facebook的论文《&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.usenix.org%2Fsystem%2Ffiles%2Fconference%2Fnsdi13%2Fnsdi13-final170_update.pdf&quot;&gt;Scaling Memcache at Facebook&lt;/a&gt;》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.quora.com%2FWhy-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend&quot;&gt;Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?&lt;/a&gt;》，主要是怕两个并发的写操作导致脏数据。&lt;/p&gt;

&lt;p&gt;那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。&lt;/p&gt;

&lt;p&gt;但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-消息中间件&quot;&gt;5 消息中间件&lt;/h2&gt;

&lt;h4 id=&quot;51--消费者获取消息有几种模式&quot;&gt;5.1  消费者获取消息有几种模式？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;推送模式:&lt;/strong&gt; consumer把轮询过程封装了，并注册到MessageListener监听器中，对于offset进行自动保存。取到消息后，唤醒MessageListener的consumeMessage()来消费，这种触发方法才会被调用的方式对用户而言感觉就像是被推送过来。&lt;/p&gt;

&lt;p&gt;__拉取模式:__这种方法非常少用，它在取消息的过程中需要用户自己手动操作。首先在要消费的Topic中拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每一个MessageQueue批量取消息，每取完一次，记录该队列下一次要取的开始offset，直到取完一整个MessageQueue，再换另一个MessageQueue。&lt;/p&gt;

&lt;h4 id=&quot;52--rocketmq的特点有哪些&quot;&gt;5.2  RocketMQ的特点有哪些？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;灵活可扩展性
RocketMQ 天然支持集群，其核心四组件（Name Server、Broker、Producer、Consumer）每一个都可以在没有单点故障的情况下进行水平扩展。&lt;/li&gt;
  &lt;li&gt;海量消息堆积能力
RocketMQ 采用零拷贝原理实现超大的消息的堆积能力，据说单机已可以支持亿级消息堆积，而且在堆积了这么多消息后依然保持写入低延迟。&lt;/li&gt;
  &lt;li&gt;支持顺序消息
可以保证消息消费者按照消息发送的顺序对消息进行消费。顺序消息分为全局有序和局部有序，一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现。&lt;/li&gt;
  &lt;li&gt;多种消息过滤方式
消息过滤分为在服务器端过滤和在消费端过滤。服务器端过滤时可以按照消息消费者的要求做过滤，优点是减少不必要消息传输，缺点是增加了消息服务器的负担，实现相对复杂。消费端过滤则完全由具体应用自定义实现，这种方式更加灵活，缺点是很多无用的消息会传输给消息消费者。&lt;/li&gt;
  &lt;li&gt;支持事务消息
RocketMQ 除了支持普通消息，顺序消息之外还支持事务消息，这个特性对于分布式事务来说提供了又一种解决思路。&lt;/li&gt;
  &lt;li&gt;回溯消费
回溯消费是指消费者已经消费成功的消息，由于业务上需求需要重新消费，RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;53--kafka-同时设置了-7-天和-10g-清除数据到第五天的时候消息达到了-10g这个时候-kafka将如何处理&quot;&gt;5.3  kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？&lt;/h4&gt;

&lt;p&gt;这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。&lt;/p&gt;

&lt;h4 id=&quot;54--为何需要kafka集群&quot;&gt;5.4  为何需要Kafka集群&lt;/h4&gt;

&lt;p&gt;提高信息吞吐量，&lt;/p&gt;

&lt;h4 id=&quot;55--kafka-数据存储设计&quot;&gt;5.5  Kafka 数据存储设计&lt;/h4&gt;

&lt;h4 id=&quot;56--kafka如何判断一个节点是否存活&quot;&gt;5.6  Kafka如何判断一个节点是否存活？&lt;/h4&gt;
&lt;p&gt;5.7 kafka消息发送的可靠性机制有几种
 5.8 请详细说一下推送模式和拉取模式。
 5.9 Kafka 与传统消息系统之间有三个关键区别&lt;/p&gt;

&lt;h4 id=&quot;510--rocketmq-由哪些角色组成&quot;&gt;5.10  RocketMQ 由哪些角色组成？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;生产者（Producer）&lt;/strong&gt;：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消费者（Consumer）&lt;/strong&gt;：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;消息服务器（Broker）&lt;/strong&gt;：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;名称服务器（NameServer）&lt;/strong&gt;：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。&lt;/p&gt;

&lt;p&gt;5.12 Kafka的消费者如何消费数据
 5.13 Kafka的优点
 5.14 Kafka 的设计是什么样的呢？
 5.15 说说你对Consumer的了解？
 5.16 Kafka新建的分区会在哪个目录下创建&lt;/p&gt;

&lt;h4 id=&quot;517--说一下kafka消费者消费过程&quot;&gt;5.17  说一下Kafka消费者消费过程&lt;/h4&gt;

&lt;p&gt;消息的消费模型有两种：推送模型(push)和拉取模型(pull)&lt;/p&gt;

&lt;p&gt;推送模型(push)：&lt;/p&gt;

&lt;p&gt;基于推送模型（push）的消息系统，由消息代理记录消费者的消费状态，消息代理在将消息推送到消费者后，标记这条消息为已消费，但这种方式无法很好地保证消息被处理，比如，消息代理把消息发送出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失（因为消息代理已经把这条消息标记为已消费了，但实际上这条消息并没有被实际处理），如果要保证消息被处理，消息代理发送完消息后，要设置状态为“已发送”，只有收到消费者的确认请求后才更新为“已消费”，这就需要消息代理中记录所有的消费状态，这种做法显然是不可取的&lt;/p&gt;

&lt;p&gt;拉取模型(pull)：&lt;/p&gt;

&lt;p&gt;Kafka采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序读取每个分区的消息，有两个消费者(不同消费者组)拉取同一个主题的消息，消费者A的消费进度是3，消费者B的消费进度是6，消费者拉取的最大上限通过最高水位(watermark)控制，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的，这种由消费者控制偏移量的优点是：消费者可以按照任意的顺序消费消息，比如：消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费&lt;/p&gt;

&lt;h4 id=&quot;518--介绍下kafka&quot;&gt;5.18  介绍下Kafka&lt;/h4&gt;

&lt;p&gt;kafka是一个 &lt;strong&gt;分布式的&lt;/strong&gt;， __可分区__的， __可备份__的日志提交服务，它使用独特的设计实现了一个消息系统的功能。&lt;/p&gt;

&lt;h4 id=&quot;519--什么情况会导致kafka运行变慢&quot;&gt;5.19  什么情况会导致Kafka运行变慢？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;cpu 性能瓶颈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;磁盘读写瓶颈&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网络瓶颈&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;520--kafka-可以脱离-zookeeper-单独使用吗为什么&quot;&gt;5.20  kafka 可以脱离 zookeeper 单独使用吗？为什么？&lt;/h4&gt;

&lt;p&gt;kafka 不能脱离 zookeeper 单独使用，&lt;/p&gt;

&lt;p&gt;因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。&lt;/p&gt;

&lt;h4 id=&quot;521--使用-kafka-集群需要注意什么&quot;&gt;5.21  使用 kafka 集群需要注意什么？&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;集群的数量不是越多越好，最好不要超过 7 个，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;522--为什么使用消息队列呢即优势所在&quot;&gt;5.22  为什么使用消息队列呢（即优势所在）？&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实现解耦&lt;/strong&gt;；举个简单例子，快递小哥手上有很多快递需要配送，若一一通知收件人，估计快递小哥要疯掉，有了丰巢快递柜后，快递小哥可以集中将快递放到快递柜子里面，后面只需发送短信给收件人即可，这样以来快递柜子就充当了消息中间件，实现了解耦，两个人互不耽误。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;实现冗余备份&lt;/strong&gt;；当快递小哥兴致冲冲的拉来一车快递后，正准备投递到丰巢快递柜子，但不幸的是蜂巢快递柜子坏了，无法投递快递，快递小哥也没招，只能老老实实的去下一个丰巢快递柜子投递快递，若快递柜子又坏了，快递小哥还可以去下一个快递柜子，如此一来，实现了消息队列的冗余备份，保证你的快递不被丢失；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;异步&lt;/strong&gt;；如果楼下有你的快递，快递小哥需要一直在楼下等你取走快递后，快递小哥才能进行下一个快递的派单，这样以来快递小哥的效率极其低下，而有了快递柜子后，快递小哥只需要将你的快递放到柜子，然后给你发送取件短信即可，这样以来效率大大提高，这正体现了中间件的好处；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;削峰&lt;/strong&gt;；当双十一来临后，快递小哥的业务量倍增，这样快递小哥直接怀疑人生，自从各种丰巢、菜鸟驿站等各种消息中间件后，快递小哥没那么繁忙了，这正是体现了消息中间件的削峰作用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;523--kafka数据丢失问题解决方案&quot;&gt;5.23  Kafka数据丢失问题解决方案?&lt;/h4&gt;

&lt;p&gt;首先对kafka进行限速， 其次启用重试机制，重试间隔时间设置长一些，最后Kafka设置 &lt;strong&gt;acks=all&lt;/strong&gt;，即需要相应的所有处于ISR的分区都确认收到该消息后，才算发送成功。&lt;/p&gt;

&lt;h4 id=&quot;524--kafka数据重复问题解决方案&quot;&gt;5.24  Kafka数据重复问题解决方案?&lt;/h4&gt;

&lt;p&gt;把kafka消费者的配置 &lt;strong&gt;enable.auto.commit设为false&lt;/strong&gt;， &lt;strong&gt;禁止kafka自动提交offset，从而使用spring-kafka提供的offset提交策略&lt;/strong&gt;。spring-kafka中的offset提交策略可以保证一批消息数据没有完成消费的情况下，也能提交offset，从而避免了提交失败而导致永远重复消费的问题。&lt;/p&gt;

&lt;h4 id=&quot;524--kafka消息是否会丢失为什么&quot;&gt;5.24  kafka消息是否会丢失？为什么？&lt;/h4&gt;

&lt;p&gt;acks参数用于控制producer生产消息的持久性（durability）。对producer而言，kafka在乎的是已提交消息的持久性。一旦消息被提交成功，那么只要有任何一个保存了消息的副本存活，这条消息被视为不会丢失的。
  acks有3个值：0,1,all(-1)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;acks=0：producer不进行消息接收是否成功的确认。&lt;/li&gt;
  &lt;li&gt;acks=1（默认）：当Leader副本接收成功后，返回接收成功确认信息；&lt;/li&gt;
  &lt;li&gt;acks=all或者-1：当Leader和Follower副本都接收成功后，返回接收成功确认信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;  从上面acks的设置中可以知道，当acks=0时，一旦发生宕机，肯定会发生消息丢失的情况；acks=1时，只要leader broker一直存活，kafka能够保证消息不丢失；acks=all时，只要还有副本存活，那么这条消息肯定不会丢失。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">1 Dubbo 1.1 服务调用超时问题怎么解决？ dubbo源码分析（二）：超时原理以及应用场景 1.2 Dubbo支持哪些序列化方式？ Hessian 序列化：是修改过的 hessian lite，默认启用 json 序列化：使用 FastJson 库 java 序列化：JDK 提供的序列化，性能不理想 dubbo 序列化：未成熟的高效 java 序列化实现，不建议在生产环境使用 1.3 Dubbo和SpringCloud的关系？ dubbo springcloud 消费者，生产者，注册中心，管理中心 消费者，生产者，注册中心，管理中心，短路器，分布式配置，消息总线，服务追踪 Netty这样的NIO框架，是基于TCP协议传输的，配合以Hession序列化完成RPC 基于Http协议+rest接口调用远程请求，相对来说，Http请求会有更大的报文，占的带宽也会更多。 dubbo类似组装机，开发相对复杂 springcloud类似一体机，一站式开发，相对简单 1.4 Dubbo的架构设计？一共划分了哪些层？ 服务接口层(Service)：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现 配置层(Config)：对外配置接口，以 ServiceConfig 和 ReferenceConfig 为中心 服务代理层(Proxy)：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton 服务注册层(Registry)：封装服务地址的注册与发现，以服务 URL 为中心 集群层(Cluster)：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心 监控层(Monitor)：RPC 调用次数和调用时间监控 远程调用层(Protocol)：封将 RPC 调用，以 Invocation 和 Result 为中心，扩展接口为 Protocol、Invoker、Exporter 信息交换层(Exchange)：封装请求响应模式，同步转异步，以 Request 和 Response 为中心 网络传输层(Transport)：抽象 mina 和 netty 为统一接口，以 Message 为中心 1.5 Dubbo的默认集群容错方案？ Failover Cluster，失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。 Failfast Cluster，快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 Failsafe Cluster，失败安全，出现异常时，直接忽略。通常用于写入日志等。 Failback Cluster，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知等。 Forking Cluster，并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks 来设置最大并行数。 Broadcast Cluster，广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存本地资源信息。 默认 Failover Cluster 1.6 Dubbo使用的是什么通信框架? 1.7 Dubbo的主要应用场景？ 1.8 Dubbo服务注册与发现的流程？流程说明。 1.9 Dubbo的集群容错方案有哪些？ 1.10 Dubbo的四大组件 1.11 Dubbo在安全机制方面是如何解决的 1.12 Dubbo和SpringCloud的区别？ 1.13 Dubbo支持哪些协议，每种协议的应用场景，优缺点？ 1.14 Dubbo的核心功能有哪些？ 1.15 Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？ 1.16 Dubbo集群的负载均衡有哪些策略 1.17 为什么需要服务治理？ 1.18 Dubbo超时时间怎样设置？ 2 ElasticSearch 2.1 你们公司的ES集群，一个node一般会分配几个分片？ 2.2 Elasticsearch是如何实现Master选举的？ 2.3 你是如何做写入调优的？ 2.4 如何避免脑裂？ 2.5 Elasticsearch对于大数据量（上亿量级）的聚合如何实现？ 2.6 ES主分片数量可以在后期更改吗？为什么？ 2.7 如何监控集群状态？ 2.8 ElasticSearch中的副本是什么？ 2.9 ES更新数据的执行流程？ 2.10 shard里面是什么组成的？ 2.11 ElasticSearch中的分析器是什么？ 2.12 什么是脑裂？ 2.13 客户端在和集群连接时，如何选择特定的节点执行请求的？ 2.14 Elasticsearch中的倒排索引是什么？ 2.15 什么是索引？索引（名词） 一个索引(index) 2.16 详细描述一下Elasticsearch更新和删除文档的过程 3 JVM 3.1 JVM参数主要有⼏种分类 IBM 微软的 hotpot 3.2 Java中会存在内存泄漏吗，简述一下。 会出现内存泄漏，当垃圾回收器清理内存后，现有内存使用量+申请新增内存&amp;gt;最大使用内存时，会出现内存泄漏 主要场景包括以下两种 机器内存不够用 内存分配不合理 3.3 Java虚拟机是如何判定两个Java类是相同的？ 在新建对象的过程中，需要新通过类加载，而在类加载中通过 双亲委派机制 来判断两个类是否相同 当某个加载器需要加载某个.class 文件时，他首先把这个任务委托过他的上一级加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 下面是类加载的过程 用于自定义类加载器 –&amp;gt; 系统类加载器 –&amp;gt; 扩展类加载 –&amp;gt; 启动类加载 3.4 Java 中都有哪些引用类型 __强引用（strongreference）__就是指在程序代码之中普遍存在的,类似“Object obj=new Object()” 这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象实例。 __软引用（softreference）__是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象, 在系统将要发生内存溢出异常之前,将会把这些对象实例列进回收范围之中进行 第二次回收。如果这次回收还没有足够的内存,才会抛出内存溢出异常。在 JDK 1.2 之后,提供了 SoftReference 类来实现软引用。 __弱引用（weakreference）__也是用来描述非必需对象的,但是它的强度比软引用更弱一些,被弱 引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时, 无论当前内存是否足够,都会回收掉只被弱引用关联的对象实例。在 JDK 1.2 之 后,提供了 WeakReference 类来实现弱引用。 __虚引用（phantomreference）__也称为幽灵引用或者幻影引用,它是最弱的一种引用关系。一个对象 实例是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用 来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象 实例被收集器回收时收到一个系统通知。在 JDK 1.2 之后,提供了 PhantomReference 类来实现虚引用 3.5 在 Java 中，对象什么时候可以被垃圾回收？ 当对象被判定已经“死去”时，对象可以被垃圾回收，判断对象是否存活可通过以下算法 __引用计数算法：__通过引用计数器，当被引用+1，当失去引用-1，计数为零的引用被清理 可达性分析算法： 通过跟对象作为起始点，从这个节点开始向下搜索，搜索过程所走的路径称为“引用链”，如果某个对象的到 __GC Roots __间没有连接，则说明该对象不能再被引用 3.6 StackOverflow异常有没有遇到过？一般你猜测会在什么情况下被触发？ 栈内存溢出。栈内存保存的信息包括：函数地址、函数参数、局部变量等 出现__栈内存溢出的常见原因有2个__： 函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈 局部静态变量体积太大 解决办法大致说来也有两种： 增加栈内存的数目 使用堆内存增加栈内存方法 3.7 堆空间分哪些部分？以及如何设置各个部分？ 新生代，老年代 其中新生代，分为 伊甸，to，from 按照 8:1:1 的比例进行分割 3.8 什么是栈帧？栈帧存储了什么？ 栈帧是方法运行期最重要的基本数据结构 存储包括：局部变量表，操作数栈，动态连接和方法返回地址 3.9 如何设置参数生成GC日志？ -XX:+PrintGC 3.10 GC 是什么？为什么要有 GC？ Garbage Collection 垃圾回收系统， java提供的gc功能可以自动检测对象是否超出通过垃圾回收系统，由系统自动触发垃圾回收。java没有提供释放垃圾已分配内存的显示操作方法 3.12 使用过哪些jdk命令，并说明各个的作用是什么 jps：__用于显示__指定系统内所有HotSpot虚拟机进程，并且能显示虚拟机执行主类以及本地虚拟机唯一ID jstat：__用于__监视虚拟机各种运行状态信息的工具，可以显示本地或者远程的虚拟机进程类装载、内存、GC、JIT等运行数据，在没有GUI图像界面的服务器上，主要就是用它在运行期定位性能问题 jmap：__用于生成堆转储快照(heapdump或dump文件)，说白了就是把java堆使用情况快照一份导出来供我们查看，__用来排查问题。 __jhat：__这个就是和jmap搭配使用的，jmap导出来的堆快照文件用jhat 打开分析 jstack：__用于生成虚拟机当前时刻线程快照(threaddump或javacore)。__主要用来定位线程出现长时间停顿的原因，判断死锁啊，死循环的等。通过jstack就可知各线程的调用堆栈情况 __jinfo：__用来查看和调整虚拟机各项参数使用格式 3.13 JVM运行时数据区区域分为哪⼏部分？ 堆，方法区，本地方法区，计数器，栈 3.14 是否了解类加载器双亲委派模型机制和破坏双亲委派模型？ 在类加载的过程中，会用到双亲委派机制，目的是为了保障.class 文件的唯一性， 他首先把这个任务委托过他的上一级加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。 双亲委派机制中类加载过程：自定义类加载器，程序类加载器，扩展类加载，系统类加载器 破坏双亲委派机制：通过继承 ClassLoader 并重写loadclass 3.15 逃逸分析有几种类型？ 方法逃逸：对象的方法被外部方法所引用 线程逃逸：方法被外部线程访问到 3.16 -Xms这些参数的含义是什么？ 设置堆内存 3.17 你知道哪几种垃圾收集器,各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。 3.18 JVM的内存结构，Eden和Survivor比例是多少？ 8:1:1 4 多线程/高并发 4.1 负载平衡的意义什么？ 提高硬件的使用率，提升系统的容量 4.2 请说出同步线程及线程调度相关的方法？ 线程调度相关方法： yield()：线程让步，暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程。若队列中没有同优先级的线程，忽略此方法。 join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止，低优先级的线程也可以获得执行 sleep(long millis)(毫秒) ： 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。 isAlive()：判断线程是否还活着 线程同步： synchronized 同步代码快，同步方法 4.3 关于epoll和select的区别，哪些说法 是正确的？（多选） A. epoll 和 select 都是 I/O 多路复用的技术，都可以实现同时监听 多个I/O事件的状态。 B. epoll 相比 select 效率更高，主要是基于其操作系统支持的 I/O 事件通知机制，而select是基于轮询机制。 C. epoll支持水平触发和边沿触发两种模式。 D. select能并行支持I/O比较小，且无法修改。 4.4 启动一个线程是调用run()方法还是start()方法？ run() 方法，start() 中饱含 run() 方法 4.5 如何确保N个线程可以访问N个资源同时又不导致死锁？ 多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可，只要破坏了其中一个条件就可以破坏死锁，其中最简单的方法就是线程都是以同样的顺序加锁和释放锁，也就是破坏了第四个条件 4.6 编写多线程程序的几种实现方式（换个问法：创建多线程的方式）？ 继承 Thread 重写run函数 实现Runnable 重写run函数 实现Callable接口，重写call函数 4.7 线程和进程的区别？ 线程是进程执行程序的最小单元 进程：一个程序一个进程 线程：一个进程包含多个线程 4.8 什么是线程池，有哪些常用线程池？ 若干个线程放入同一个容器中，使用的时候从池中获取而不用自行创建，使用完毕不需 要销毁线程而是放回池中， 从而减少创建和销毁线程对象的开销 常用线程池： __newSingleThreadExecutor： __创建一个单线程的线程池， 此线程池保证所有任务的执行顺序按照任务的 提交顺序执行。 __newFixedThreadPool： __创建固定大小的线程池， 每次提交一个任务就创建一个线程， 直到线程达到线 程池的最大大小。 newCachedThreadPool： 创建一个可缓存的线程池， 此线程池不会对线程池大小做限制， 线程池大小 完全依赖于操作系统（或者说 JVM） 能够创建的最大线程大小。 __newScheduledThreadPool： __创建一个大小无限的线程池， 此线程池支持定时以及周期性执行任务的需 求。 __newSingleThreadExecutor： __创建一个单线程的线程池。 此线程池支持定时以及周期性执行任务的需 求 4.9 什么是死锁？ 是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进 多线程产生死锁需要四个条件，分别是互斥性，保持和请求，不可剥夺性还有要形成闭环，这四个条件缺一不可 4.10 怎么保证缓存和数据库数据的一致性？ Cache aside （旁路缓存 ） 这是最常用最常用的pattern了。其具体逻辑如下： 失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。 命中：应用程序从cache中取数据，取到后返回。 更新：先把数据存到数据库中，成功后，再让缓存失效。 注意，我们的更新是先更新数据库，成功后，让缓存失效。那么，这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。 一个是查询操作，一个是更新操作的并发，首先，没有了删除cache数据的操作了，而是先更新了数据库中的数据，此时，缓存依然有效，所以，并发的查询操作拿的是没有更新的数据，但是，更新操作马上让缓存的失效了，后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题，后续的查询操作一直都在取老的数据。 这是标准的design pattern，包括Facebook的论文《Scaling Memcache at Facebook》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?》，主要是怕两个并发的写操作导致脏数据。 那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。 但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。 所以，这也就是Quora上的那个答案里说的，要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率，而Facebook使用了这个降低概率的玩法，因为2PC太慢，而Paxos太复杂。当然，最好还是为缓存设置上过期时间。 5 消息中间件 5.1 消费者获取消息有几种模式？ 推送模式: consumer把轮询过程封装了，并注册到MessageListener监听器中，对于offset进行自动保存。取到消息后，唤醒MessageListener的consumeMessage()来消费，这种触发方法才会被调用的方式对用户而言感觉就像是被推送过来。 __拉取模式:__这种方法非常少用，它在取消息的过程中需要用户自己手动操作。首先在要消费的Topic中拿到MessageQueue的集合，遍历MessageQueue集合，然后针对每一个MessageQueue批量取消息，每取完一次，记录该队列下一次要取的开始offset，直到取完一整个MessageQueue，再换另一个MessageQueue。 5.2 RocketMQ的特点有哪些？ 灵活可扩展性 RocketMQ 天然支持集群，其核心四组件（Name Server、Broker、Producer、Consumer）每一个都可以在没有单点故障的情况下进行水平扩展。 海量消息堆积能力 RocketMQ 采用零拷贝原理实现超大的消息的堆积能力，据说单机已可以支持亿级消息堆积，而且在堆积了这么多消息后依然保持写入低延迟。 支持顺序消息 可以保证消息消费者按照消息发送的顺序对消息进行消费。顺序消息分为全局有序和局部有序，一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现。 多种消息过滤方式 消息过滤分为在服务器端过滤和在消费端过滤。服务器端过滤时可以按照消息消费者的要求做过滤，优点是减少不必要消息传输，缺点是增加了消息服务器的负担，实现相对复杂。消费端过滤则完全由具体应用自定义实现，这种方式更加灵活，缺点是很多无用的消息会传输给消息消费者。 支持事务消息 RocketMQ 除了支持普通消息，顺序消息之外还支持事务消息，这个特性对于分布式事务来说提供了又一种解决思路。 回溯消费 回溯消费是指消费者已经消费成功的消息，由于业务上需求需要重新消费，RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯 5.3 kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka将如何处理？ 这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。 5.4 为何需要Kafka集群 提高信息吞吐量， 5.5 Kafka 数据存储设计 5.6 Kafka如何判断一个节点是否存活？ 5.7 kafka消息发送的可靠性机制有几种 5.8 请详细说一下推送模式和拉取模式。 5.9 Kafka 与传统消息系统之间有三个关键区别 5.10 RocketMQ 由哪些角色组成？ 生产者（Producer）：负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。 消费者（Consumer）：负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。 消息服务器（Broker）：是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。 名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。 5.12 Kafka的消费者如何消费数据 5.13 Kafka的优点 5.14 Kafka 的设计是什么样的呢？ 5.15 说说你对Consumer的了解？ 5.16 Kafka新建的分区会在哪个目录下创建 5.17 说一下Kafka消费者消费过程 消息的消费模型有两种：推送模型(push)和拉取模型(pull) 推送模型(push)： 基于推送模型（push）的消息系统，由消息代理记录消费者的消费状态，消息代理在将消息推送到消费者后，标记这条消息为已消费，但这种方式无法很好地保证消息被处理，比如，消息代理把消息发送出去后，当消费进程挂掉或者由于网络原因没有收到这条消息时，就有可能造成消息丢失（因为消息代理已经把这条消息标记为已消费了，但实际上这条消息并没有被实际处理），如果要保证消息被处理，消息代理发送完消息后，要设置状态为“已发送”，只有收到消费者的确认请求后才更新为“已消费”，这就需要消息代理中记录所有的消费状态，这种做法显然是不可取的 拉取模型(pull)： Kafka采用拉取模型，由消费者自己记录消费状态，每个消费者互相独立地顺序读取每个分区的消息，有两个消费者(不同消费者组)拉取同一个主题的消息，消费者A的消费进度是3，消费者B的消费进度是6，消费者拉取的最大上限通过最高水位(watermark)控制，生产者最新写入的消息如果还没有达到备份数量，对消费者是不可见的，这种由消费者控制偏移量的优点是：消费者可以按照任意的顺序消费消息，比如：消费者可以重置到旧的偏移量，重新处理之前已经消费过的消息；或者直接跳到最近的位置，从当前的时刻开始消费 5.18 介绍下Kafka kafka是一个 分布式的， __可分区__的， __可备份__的日志提交服务，它使用独特的设计实现了一个消息系统的功能。 5.19 什么情况会导致Kafka运行变慢？ cpu 性能瓶颈 磁盘读写瓶颈 网络瓶颈 5.20 kafka 可以脱离 zookeeper 单独使用吗？为什么？ kafka 不能脱离 zookeeper 单独使用， 因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。 5.21 使用 kafka 集群需要注意什么？ 集群的数量不是越多越好，最好不要超过 7 个， 因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。 集群数量最好是单数，因为超过一半故障集群就不能用了，设置为单数容错率更高。 5.22 为什么使用消息队列呢（即优势所在）？ 实现解耦；举个简单例子，快递小哥手上有很多快递需要配送，若一一通知收件人，估计快递小哥要疯掉，有了丰巢快递柜后，快递小哥可以集中将快递放到快递柜子里面，后面只需发送短信给收件人即可，这样以来快递柜子就充当了消息中间件，实现了解耦，两个人互不耽误。 实现冗余备份；当快递小哥兴致冲冲的拉来一车快递后，正准备投递到丰巢快递柜子，但不幸的是蜂巢快递柜子坏了，无法投递快递，快递小哥也没招，只能老老实实的去下一个丰巢快递柜子投递快递，若快递柜子又坏了，快递小哥还可以去下一个快递柜子，如此一来，实现了消息队列的冗余备份，保证你的快递不被丢失； 异步；如果楼下有你的快递，快递小哥需要一直在楼下等你取走快递后，快递小哥才能进行下一个快递的派单，这样以来快递小哥的效率极其低下，而有了快递柜子后，快递小哥只需要将你的快递放到柜子，然后给你发送取件短信即可，这样以来效率大大提高，这正体现了中间件的好处； 削峰；当双十一来临后，快递小哥的业务量倍增，这样快递小哥直接怀疑人生，自从各种丰巢、菜鸟驿站等各种消息中间件后，快递小哥没那么繁忙了，这正是体现了消息中间件的削峰作用。 5.23 Kafka数据丢失问题解决方案? 首先对kafka进行限速， 其次启用重试机制，重试间隔时间设置长一些，最后Kafka设置 acks=all，即需要相应的所有处于ISR的分区都确认收到该消息后，才算发送成功。 5.24 Kafka数据重复问题解决方案? 把kafka消费者的配置 enable.auto.commit设为false， 禁止kafka自动提交offset，从而使用spring-kafka提供的offset提交策略。spring-kafka中的offset提交策略可以保证一批消息数据没有完成消费的情况下，也能提交offset，从而避免了提交失败而导致永远重复消费的问题。 5.24 kafka消息是否会丢失？为什么？ acks参数用于控制producer生产消息的持久性（durability）。对producer而言，kafka在乎的是已提交消息的持久性。一旦消息被提交成功，那么只要有任何一个保存了消息的副本存活，这条消息被视为不会丢失的。   acks有3个值：0,1,all(-1) acks=0：producer不进行消息接收是否成功的确认。 acks=1（默认）：当Leader副本接收成功后，返回接收成功确认信息； acks=all或者-1：当Leader和Follower副本都接收成功后，返回接收成功确认信息。   从上面acks的设置中可以知道，当acks=0时，一旦发生宕机，肯定会发生消息丢失的情况；acks=1时，只要leader broker一直存活，kafka能够保证消息不丢失；acks=all时，只要还有副本存活，那么这条消息肯定不会丢失。</summary></entry><entry><title type="html">阻塞式编程和非阻塞式编程</title><link href="http://localhost:4000/mianshi/thread/0818" rel="alternate" type="text/html" title="阻塞式编程和非阻塞式编程" /><published>2020-08-18T00:00:00+08:00</published><updated>2020-08-18T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/thread/%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BC%96%E7%A8%8B</id><content type="html" xml:base="http://localhost:4000/mianshi/thread/0818">&lt;ul&gt;
  &lt;li&gt;阻塞IO的含义
    &lt;ol&gt;
      &lt;li&gt;阻塞（blocking）IO：资源不可用时，IO请求一直阻塞，知道反馈结果（有数据或者超时）。&lt;/li&gt;
      &lt;li&gt;非阻塞（non-blocking）IO：资源不可用时，IO请求离开返回，返回数据标识资源不可用。&lt;/li&gt;
      &lt;li&gt;同步（synchronous）IO：应用组社发送或接受说句状态，知道数据成功传输或返回失败。&lt;/li&gt;
      &lt;li&gt;异步（asynchronous）IO：应用发送或接受数据后立刻返回，实际处理是异步执行的。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;阻塞和非阻塞是获取资源的方式。同步/异步是程序如何处理资源的逻辑设计。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码中使用的API：ServerSocket#accept、InputStream#read都是阻塞的API。&lt;strong&gt;操作系统底层API中，默认操作都是Blocking型&lt;/strong&gt;。sent./rec等接口都是阻塞的。&lt;/p&gt;

&lt;p&gt;带来的问题：阻塞导致处理网络I/O时，一个线程只能处理一个网络连接。&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">阻塞IO的含义 阻塞（blocking）IO：资源不可用时，IO请求一直阻塞，知道反馈结果（有数据或者超时）。 非阻塞（non-blocking）IO：资源不可用时，IO请求离开返回，返回数据标识资源不可用。 同步（synchronous）IO：应用组社发送或接受说句状态，知道数据成功传输或返回失败。 异步（asynchronous）IO：应用发送或接受数据后立刻返回，实际处理是异步执行的。 阻塞和非阻塞是获取资源的方式。同步/异步是程序如何处理资源的逻辑设计。 代码中使用的API：ServerSocket#accept、InputStream#read都是阻塞的API。操作系统底层API中，默认操作都是Blocking型。sent./rec等接口都是阻塞的。 带来的问题：阻塞导致处理网络I/O时，一个线程只能处理一个网络连接。</summary></entry><entry><title type="html">Autowired的使用：推荐使用构造函数进行注入</title><link href="http://localhost:4000/spring/0709/01" rel="alternate" type="text/html" title="Autowired的使用：推荐使用构造函数进行注入" /><published>2020-07-09T00:00:00+08:00</published><updated>2020-07-09T00:00:00+08:00</updated><id>http://localhost:4000/spring/0709/Autowired%E7%9A%84%E4%BD%BF%E7%94%A8:%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5</id><content type="html" xml:base="http://localhost:4000/spring/0709/01">&lt;p&gt;近期看同事用idea开发的代码，发现在使用@Autowired的时候，大多使用构造函数进行注入。&lt;/p&gt;

&lt;p&gt;以前自己在写代码的时候都是直接在变量上进行注入，也没注意过，查了些资料，发现如果直接在变量上进行注入，那么可能会造成&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NPE&lt;/code&gt;。&lt;/p&gt;

&lt;h5 id=&quot;构造函数注入的方式&quot;&gt;构造函数注入的方式：&lt;/h5&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;       &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;testService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;       &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; &lt;/p&gt;

&lt;h5 id=&quot;变量注入的方式&quot;&gt;变量注入的方式：&lt;/h5&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;       &lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;          &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;那么为什么变量注入的方式可能会造成npe如下&quot;&gt;那么为什么变量注入的方式可能会造成NPE？如下：&lt;/h5&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;       &lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;testname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTestName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这段代码执行时会报NPE。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;该类的构造函数中的变量值是通过TestService实例来调用TestService类中的方法获得，而Java类会先执行构造函数，然后在通过@Autowired注入实例，因此在执行构造函数的时候就会报错。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;解决方案就是采用构造函数的注入方式，如下：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestController&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;   &lt;/span&gt; &lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testname&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;       &lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;         &lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TestController&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TestService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;testService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;testname&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;testService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getTestName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;err&quot;&gt; &lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的方法中没有加入final来修饰，但是spring官方文档上是建议将成员变量加上final类型的，这是为什么呢？&lt;/p&gt;

&lt;p&gt;有网友解释：&lt;/p&gt;

&lt;p&gt;1.spring配置默认的bean的scope是singleton,可以通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton,注入只执行一次。&lt;/p&gt;

&lt;p&gt;2.@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。&lt;/p&gt;

&lt;p&gt;无论是spring的bean的scope是单例还是多例，成员变量加上了final后，只能被赋值一次，赋值后值不再改变。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;
&lt;h5 id=&quot;注意&quot;&gt;注意：&lt;/h5&gt;

&lt;p&gt;1.如果使用变量注入的话，可能回导致循环依赖，即A里面注入B，B里面又注入A。&lt;/p&gt;

&lt;p&gt;2.在代码中发现构造方法中注入了很多依赖，显得很臃肿，对于这个问题，说明类中有太多的责任，违反了类的单一性职责原则，这时候需要考虑使用单一职责原则进行代码重构&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">近期看同事用idea开发的代码，发现在使用@Autowired的时候，大多使用构造函数进行注入。 以前自己在写代码的时候都是直接在变量上进行注入，也没注意过，查了些资料，发现如果直接在变量上进行注入，那么可能会造成NPE。 构造函数注入的方式： public class TestController { private final TestService testService;         @Autowired         public TestController(TestService testService) {                 this.testService = testService;         }         … }   变量注入的方式： public class TestController {         @Autowired         private TestService testService;               …  } 那么为什么变量注入的方式可能会造成NPE？如下： public class TestController {         @Autowired         private TestService testService;         private String testname;                  public TestController(){                          this.testname = testService.getTestName();                  }  } 这段代码执行时会报NPE。 该类的构造函数中的变量值是通过TestService实例来调用TestService类中的方法获得，而Java类会先执行构造函数，然后在通过@Autowired注入实例，因此在执行构造函数的时候就会报错。 解决方案就是采用构造函数的注入方式，如下： public class TestController {         private TestService testService;         private String testname;         @Autowired          public TestController(TestService testService){                 this.testService = testService;                 this.testname = testService.getTestName();           }  } 上面的方法中没有加入final来修饰，但是spring官方文档上是建议将成员变量加上final类型的，这是为什么呢？ 有网友解释： 1.spring配置默认的bean的scope是singleton,可以通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton,注入只执行一次。 2.@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。 无论是spring的bean的scope是单例还是多例，成员变量加上了final后，只能被赋值一次，赋值后值不再改变。   注意： 1.如果使用变量注入的话，可能回导致循环依赖，即A里面注入B，B里面又注入A。 2.在代码中发现构造方法中注入了很多依赖，显得很臃肿，对于这个问题，说明类中有太多的责任，违反了类的单一性职责原则，这时候需要考虑使用单一职责原则进行代码重构</summary></entry><entry><title type="html">sql语句优化</title><link href="http://localhost:4000/mianshi/mysql/0708/03" rel="alternate" type="text/html" title="sql语句优化" /><published>2020-07-08T00:00:00+08:00</published><updated>2020-07-08T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/mysql/0708/sql%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96</id><content type="html" xml:base="http://localhost:4000/mianshi/mysql/0708/03">&lt;h4 id=&quot;性能不理想的系统&quot;&gt;性能不理想的系统：&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;应用程序的负载确实超过了服务器的实际处理能力外&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;系统存在大量的SQL语句需要优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;优化原则一sql语句越简单越好&quot;&gt;优化原则一：SQL语句越简单越好&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;不要有超过5个以上的表连接（JOIN）&lt;/li&gt;
  &lt;li&gt;考虑使用临时表或表变量存放中间结果。&lt;/li&gt;
  &lt;li&gt;少用子查询&lt;/li&gt;
  &lt;li&gt;视图嵌套不要过深,一般视图嵌套不要超过2个为宜。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;使用推荐&quot;&gt;使用推荐：&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;连接的表越多，其编译的时间和连接的开销也越大，性能越不好控制。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最好是把连接拆开成较小的几个部分逐个顺序执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;优先执行那些能够大量减少结果的连接。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拆分的好处不仅仅是减少SQL Server优化的时间，更使得SQL语句能够以你可以预测的方式和顺序执行。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果一定需要连接很多表才能得到数据，那么很可能意味着设计上的缺陷。&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;outer-join-使用的缺点&quot;&gt;outer join 使用的缺点&lt;/h5&gt;
&lt;p&gt;连接是outer join，非常不好。因为outer join意味着必须对左表或右表查询所有行。&lt;strong&gt;如果表很大而没有相应的where语句，那么outer join很容易导致table scan或index scan。&lt;/strong&gt; 要尽量使用inner join避免scan整个表。&lt;/p&gt;

&lt;h4 id=&quot;优化建议&quot;&gt;优化建议：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;使用临时表存放t1表的结果,能大大减少logical reads（或返回行数）的操作要优先执行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;仔细分析语句，你会发现where中的条件全是针对表t1的，所以直接使用上面的where子句查询表t1，然后把结果存放再临时表＃t1中：&lt;/p&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tt1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;和上面的&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;一样&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;再把＃tt1和其他表进行连接:
    &lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;Select&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;Left&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;修改 like 程序&lt;/strong&gt;，去掉前置百分号。like语句却因为前置百分号而无法使用索引&lt;/li&gt;
  &lt;li&gt;从系统设计的角度修改语句，去掉outer join。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;考虑组合索引或覆盖索引消除&lt;/strong&gt; clustered index scan。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;上面1和2点建议立即消除了worktable，性能提高了几倍以上，效果非常明显。&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;限制结果集&quot;&gt;限制结果集&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;要尽量减少返回的结果行，包括行数和字段列数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回的结果越大，意味着相应的SQL语句的logical reads 就越大，对服务器的性能影响就越甚。&lt;/p&gt;

&lt;p&gt;一个很不好的设计就是返回表的所有数据：&lt;/p&gt;

&lt;p&gt;Select * from tablename&lt;/p&gt;

&lt;p&gt;即使表很小也会导致并发问题。更坏的情况是，如果表有上百万行的话，那后果将是灾难性的。&lt;/p&gt;

&lt;p&gt;它不但可能带来极重的磁盘IO，更有可能把数据库缓冲区中的其他缓存数据挤出，使得这些数据下次必须再从磁盘读取。&lt;/p&gt;

&lt;p&gt;必须设计良好的SQL语句，使得其有where语句或TOP语句来限制结果集大小。&lt;/p&gt;

&lt;h5 id=&quot;合理的表设计&quot;&gt;合理的表设计&lt;/h5&gt;

&lt;p&gt;SQL Server 2005将支持表分区技术。利用表分区技术可以实现数据表的流动窗口功能。&lt;/p&gt;

&lt;p&gt;在流动窗口中可以轻易的把历史数据移出，把新的数据加入，从而使表的大小基本保持稳定。&lt;/p&gt;

&lt;p&gt;另外，表的设计未必需要非常范式化。有一定的字段冗余可以增加SQL语句的效率，减少JOIN的数目，提高语句的执行速度。&lt;/p&gt;

&lt;h5 id=&quot;olap和oltp模块要分开&quot;&gt;OLAP和OLTP模块要分开&lt;/h5&gt;

&lt;p&gt;OLAP和OLTP类型的语句是截然不同的。前者往往需要扫描整个表做统计分析，索引对这样的语句几乎没有多少用处。&lt;/p&gt;

&lt;p&gt;索引只能够加快那些如sum，group by之类的聚合运算。因为这个原因，几乎很难对OLAP类型的SQL语句进行优化。&lt;/p&gt;

&lt;p&gt;而OLTP语句则只需要访问表的很小一部分数据，而且这些数据往往可以从内存缓存中得到。&lt;/p&gt;

&lt;p&gt;为了避免OLAP 和OLTP语句相互影响，这两类模块需要分开运行在不同服务器上。&lt;/p&gt;

&lt;p&gt;因为OLAP语句几乎都是读取数据，没有更新和写入操作，所以一个好的经验是配置一台standby 服务器，然后OLAP只访问standby服务器。&lt;/p&gt;

&lt;h5 id=&quot;使用存储过程&quot;&gt;使用存储过程&lt;/h5&gt;

&lt;p&gt;可以考虑使用存储过程封装那些复杂的SQL语句或商业逻辑，这样做有几个好处。&lt;/p&gt;

&lt;p&gt;一是存储过程的执行计划可以被缓存在内存中较长时间，减少了重新编译的时间。&lt;/p&gt;

&lt;p&gt;二是存储过程减少了客户端和服务器的繁复交互。&lt;/p&gt;

&lt;p&gt;三是如果程序发布后需要做某些改变你可以直接修改存储过程而不用修改程序，避免需要重新安装部署程序。&lt;/p&gt;

&lt;h4 id=&quot;索引优化&quot;&gt;索引优化&lt;/h4&gt;

&lt;p&gt;很多数据库系统性能不理想是因为系统没有经过整体优化，存在大量性能低下的SQL 语句。&lt;/p&gt;

&lt;p&gt;这类SQL语句性能不好的首要原因是缺乏高效的索引。&lt;/p&gt;

&lt;p&gt;没有索引除了导致语句本身运行速度慢外，更是导致大量的磁盘读写操作，使得整个系统性能都受之影响而变差。&lt;/p&gt;

&lt;p&gt;解决这类系统的首要办法是优化这些没有索引或索引不够好的SQL语句。&lt;/p&gt;

&lt;p&gt;创建索引的关键&lt;/p&gt;

&lt;p&gt;优化SQL语句的关键是尽可能减少语句的logical reads。&lt;/p&gt;

&lt;p&gt;这里说的logical reads是指语句执行时需要访问的单位为8K的数据页总数。&lt;/p&gt;

&lt;p&gt;logical reads 越少，其需要的内存和CPU时间也就越少，语句执行速度就越快。&lt;/p&gt;

&lt;p&gt;不言而喻，索引的最大好处是它可以极大减少SQL语句的logical reads数目，从而极大减少语句的执行时间。&lt;/p&gt;

&lt;p&gt;创建索引的关键是索引要能够大大减少语句的logical reads。一个索引好不好，主要看它减少的logical reads多不多。&lt;/p&gt;

&lt;p&gt;运行set statistics io命令可以得到SQL语句的logical reads信息。&lt;/p&gt;

&lt;p&gt;set statistics io on&lt;/p&gt;

&lt;p&gt;select au_id,au_lname ,au_fname&lt;/p&gt;

&lt;p&gt;from pubs..authors where au_lname =’Green’&lt;/p&gt;

&lt;p&gt;set statistics io on&lt;/p&gt;

&lt;p&gt;如果Logical reads很大，而返回的行数很少，也即两者相差较大，那么往往意味者语句需要优化。&lt;/p&gt;

&lt;p&gt;Logical reads中包含该语句从内存数据缓冲区中访问的页数和从物理磁盘读取的页数。&lt;/p&gt;

&lt;p&gt;而physical reads表示那些没有驻留在内存缓冲区中需要从磁盘读取的数据页。&lt;/p&gt;

&lt;p&gt;Read-ahead reads是SQL Server为了提高性能而产生的预读。预读可能会多读取一些数据。&lt;/p&gt;

&lt;p&gt;优化的时候我们主要关注Logical Reads就可以了。&lt;/p&gt;

&lt;p&gt;注意如果physical Reads或Read-ahead reads很大，那么往往意味着语句的执行时间（duration）里面会有一部分耗费在等待物理磁盘IO上。&lt;/p&gt;

&lt;p&gt;二、单字段索引，组合索引和覆盖索引&lt;/p&gt;

&lt;p&gt;单字段索引是指只有一个字段的索引，而组合索引指有多个字段构成的索引。&lt;/p&gt;

&lt;p&gt;1． 对出现在where子句中的字段加索引&lt;/p&gt;

&lt;p&gt;set statistics profile on&lt;/p&gt;

&lt;p&gt;set statistics io on&lt;/p&gt;

&lt;p&gt;go&lt;/p&gt;

&lt;p&gt;select …. from tb where …&lt;/p&gt;

&lt;p&gt;go&lt;/p&gt;

&lt;p&gt;set statistics profile off&lt;/p&gt;

&lt;p&gt;set statistics io off&lt;/p&gt;

&lt;p&gt;set statistics profile命令将输出语句的执行计划。&lt;/p&gt;

&lt;p&gt;也许你会问，为什么不用SET SHOWPLAN_ALL呢？使用SET SHOWPLAN_ALL也是可以的。&lt;/p&gt;

&lt;p&gt;不过set statistics profile输出的是SQL 语句的运行时候真正使用的执行计划，&lt;/p&gt;

&lt;p&gt;而SET SHOWPLAN_ALL输出的是预计（Estimate）的执行计划。&lt;/p&gt;

&lt;p&gt;使用SET SHOWPLAN_ALL是后面的语句并不会真正运行。&lt;/p&gt;

&lt;p&gt;用了Table Scan，也就是对整个表进行了全表扫描。全表扫描的性能通常是很差的，要尽量避免。&lt;/p&gt;

&lt;p&gt;如果上面的select语句是数据库系统经常运行的关键语句， 那么应该对它创建相应的索引。&lt;/p&gt;

&lt;p&gt;创建索引的技巧之一是对经常出现在where条件中的字段创建索引&lt;/p&gt;

&lt;p&gt;Table Scan也变成了Index Seek，性能极大提高&lt;/p&gt;

&lt;p&gt;设法避免Table scan或Index scan是优化SQL 语句使用的常用技巧。通常Index Seek需要的logical reads比前两者要少得多。&lt;/p&gt;

&lt;p&gt;2．组合索引&lt;/p&gt;

&lt;p&gt;如果where语句中有多个字段，那么可以考虑创建组合索引。&lt;/p&gt;

&lt;p&gt;组合索引中字段的顺序是非常重要的，越是唯一的字段越是要靠前。&lt;/p&gt;

&lt;p&gt;另外，无论是组合索引还是单个列的索引，尽量不要选择那些唯一性很低的字段。&lt;/p&gt;

&lt;p&gt;比如说，在只有两个值0和1的字段上建立索引没有多大意义。&lt;/p&gt;

&lt;p&gt;所以如果对单字段进行索引，建议使用set statistics profile来验证索引确实被充分使用。logical reads越少的索引越好。&lt;/p&gt;

&lt;p&gt;3．覆盖索引&lt;/p&gt;

&lt;p&gt;覆盖索引能够使得语句不需要访问表仅仅访问索引就能够得到所有需要的数据。&lt;/p&gt;

&lt;p&gt;因为聚集索引叶子节点就是数据所以无所谓覆盖与否，所以覆盖索引主要是针对非聚集索引而言。&lt;/p&gt;

&lt;p&gt;执行计划中除了index seek外，还有一个Bookmark Lookup关键字。&lt;/p&gt;

&lt;p&gt;Bookmark Lookup表示语句在访问索引后还需要对表进行额外的Bookmark Lookup操作才能得到数据。&lt;/p&gt;

&lt;p&gt;也就是说为得到一行数据起码有两次IO，一次访问索引，一次访问基本表。&lt;/p&gt;

&lt;p&gt;如果语句返回的行数很多，那么Bookmark Lookup操作的开销是很大的。&lt;/p&gt;

&lt;p&gt;覆盖索引能够避免昂贵的Bookmark Lookup操作，减少IO的次数，提高语句的性能。&lt;/p&gt;

&lt;p&gt;覆盖索引需要包含select子句和WHERE子句中出现的所有字段。Where语句中的字段在前面，select中的在后面。&lt;/p&gt;

&lt;p&gt;logical reads，是大大减少了。Bookmark Lookup操作也消失了。所以创建覆盖索引是减少logical reads提升语句性能的非常有用的优化技巧。&lt;/p&gt;

&lt;p&gt;实际上索引的创建原则是比较复杂的。有时候你无法在索引中包含了Where子句中所有的字段。&lt;/p&gt;

&lt;p&gt;在考虑索引是否应该包含一个字段时，应考虑该字段在语句中的作用。&lt;/p&gt;

&lt;p&gt;比如说如果经常以某个字段作为where条件作精确匹配返回很少的行，那么就绝对值得为这个字段建立索引。&lt;/p&gt;

&lt;p&gt;再比如说，对那些非常唯一的字段如主键和外键，经常出现在group by，order by中的字段等等都值得创建索引。&lt;/p&gt;

&lt;p&gt;问题1，是否值得在identity字段上建立聚集索引。&lt;/p&gt;

&lt;p&gt;答案取决于identity 字段如何在语句中使用。如果你经常根据该字段搜索返回很少的行，那么在其上建立索引是值得的。&lt;/p&gt;

&lt;p&gt;反之如果identity字段根本很少在语句中使用，那么就不应该对其建立任何索引。&lt;/p&gt;

&lt;p&gt;问题2，一个表应该建立多少索引合适。&lt;/p&gt;

&lt;p&gt;如果表的80％以上的语句都是读操作，那么索引可以多些。但是不要太多。&lt;/p&gt;

&lt;p&gt;特别是不要对那些更新频繁的表其建立很多的索引。很少表有超过5个以上的索引。&lt;/p&gt;

&lt;p&gt;过多的索引不但增加其占用的磁盘空间，也增加了SQL Server 维护索引的开销。&lt;/p&gt;

&lt;p&gt;问题4：为什么SQL Server 在执行计划中没有使用你认为应该使用的索引？原因是多样的。&lt;/p&gt;

&lt;p&gt;一种原因是该语句返回的结果超过了表的20％数据，使得SQL Server 认为scan比seek更有效。&lt;/p&gt;

&lt;p&gt;另一种原因可能是表字段的statistics过期了，不能准确反映数据的分布情况。&lt;/p&gt;

&lt;p&gt;你可以使用命令UPDATE STATISTICS tablename with FULLSCAN来更新它。&lt;/p&gt;

&lt;p&gt;只有同步的准确的statistics才能保证SQL Server 产生正确的执行计划。&lt;/p&gt;

&lt;p&gt;过时的老的statistics常会导致SQL Server生成不够优化的甚至愚蠢的执行计划。&lt;/p&gt;

&lt;p&gt;所以如果你的表频繁更新，而你又觉得和之相关的SQL语句运行缓慢，不妨试试UPDATE STATISTIC with FULLSCAN 语句。&lt;/p&gt;

&lt;p&gt;问题5、什么使用聚集索引，什么时候使用非聚集索引&lt;/p&gt;

&lt;p&gt;在SQL Server 中索引有聚集索引和非聚集索引两种。它们的主要差别是前者的索引叶子就是数据本身，而后者的叶子节点包含的是指向数据的书签（即数据行号或聚集索引的key）。&lt;/p&gt;

&lt;p&gt;对一个表而言聚集索引只能有一个，而非聚集索引可以有多个。&lt;/p&gt;

&lt;p&gt;只是聚集索引没有Bookmark Lookup操作。&lt;/p&gt;

&lt;p&gt;什么时候应该使用聚集索引?  什么时候使用非聚集索引? 取决于应用程序的访问模式。&lt;/p&gt;

&lt;p&gt;我的建议是在那些关键的字段上使用聚集索引。一个表一般都需要建立一个聚集索引。&lt;/p&gt;

&lt;p&gt;对于什么时候使用聚集索引，SQL Server 2000联机手册中有如下描述：&lt;/p&gt;

&lt;p&gt;在创建聚集索引之前，应先了解您的数据是如何被访问的。可考虑将聚集索引用于：&lt;/p&gt;

&lt;p&gt;包含大量非重复值的列。&lt;/p&gt;

&lt;p&gt;使用下列运算符返回一个范围值的查询：BETWEEN、&amp;gt;、&amp;gt;=、&amp;lt; 和 &amp;lt;=。&lt;/p&gt;

&lt;p&gt;被连续访问的列。&lt;/p&gt;

&lt;p&gt;返回大型结果集的查询。&lt;/p&gt;

&lt;p&gt;经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。&lt;/p&gt;

&lt;p&gt;对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。&lt;/p&gt;

&lt;p&gt;OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。应在主键上创建聚集索引。&lt;/p&gt;

&lt;p&gt;聚集索引不适用于：&lt;/p&gt;

&lt;p&gt;频繁更改的列&lt;/p&gt;

&lt;p&gt;这将导致整行移动（因为 SQL Server 必须按物理顺序保留行中的数据值）。这一点要特别注意，因为在大数据量事务处理系统中数据是易失的。&lt;/p&gt;

&lt;p&gt;宽键&lt;/p&gt;

&lt;p&gt;来自聚集索引的键值由所有非聚集索引作为查找键使用，因此存储在每个非聚集索引的叶条目内。&lt;/p&gt;

&lt;p&gt;总结：&lt;/p&gt;

&lt;p&gt;如何使一个性能缓慢的系统运行更快更高效，不但需要整体分析数据库系统，找出系统的性能瓶颈，更需要优化数据库系统发出的SQL 语句。&lt;/p&gt;

&lt;p&gt;一旦找出关键的SQL 语句并加与优化，性能问题就会迎刃而解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0708/1221791481690.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;《 数据库技术内幕 》&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理百万级以上的数据提高查询速度的方法：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;.应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
   select id from t where num is null
   可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
   select id from t where num=&lt;strong&gt;0
**
 **4&lt;/strong&gt;.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：
   select id from t where num=&lt;strong&gt;10&lt;/strong&gt; or num=&lt;strong&gt;20&lt;/strong&gt;
   可以这样查询：
   select id from t where num=&lt;strong&gt;10&lt;/strong&gt;
   union all
   select id from t where num=&lt;strong&gt;20
**
 **5&lt;/strong&gt;.下面的查询也将导致全表扫描：(不能前置百分号)
   select id from t where name like ‘%abc%’
  若要提高效率，可以考虑全文检索。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;.in 和 not in 也要慎用，否则会导致全表扫描，如：
   select id from t where num in(&lt;strong&gt;1&lt;/strong&gt;,&lt;strong&gt;2&lt;/strong&gt;,&lt;strong&gt;3&lt;/strong&gt;)
   对于连续的数值，能用 between 就不要用 in 了：
   select id from t where num between &lt;strong&gt;1&lt;/strong&gt; and **3&lt;/p&gt;

&lt;p&gt;**&lt;/p&gt;

&lt;p&gt;select xx,phone FROM send a JOIN (
 select ‘13891030091’ phone union select ‘13992085916’ ………… UNION SELECT ‘13619100234’ ) b
 on a.Phone=b.phone
–替代下面 很多数据隔开的时候
in(‘13891030091’,’13992085916’,’13619100234’…………)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：
   select id from t where num=@num   可以改为强制查询使用索引：
   select id from t with(index(索引名)) where &lt;a href=&quot;mailto:num=@num&quot;&gt;num&lt;/a&gt;&lt;a href=&quot;mailto:num=@num&quot;&gt;=@num&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
   select id from t where num/&lt;strong&gt;2&lt;/strong&gt;=&lt;strong&gt;100&lt;/strong&gt;
   应改为:
   select id from t where num=&lt;strong&gt;100&lt;/strong&gt;&lt;strong&gt;*2
**
 **9&lt;/strong&gt;.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
   select id from t where substring(name,&lt;strong&gt;1&lt;/strong&gt;,&lt;strong&gt;3&lt;/strong&gt;)=’abc’–name以abc开头的id
   select id from t where datediff(day,createdate,’&lt;strong&gt;2005&lt;/strong&gt;-&lt;strong&gt;11&lt;/strong&gt;-&lt;strong&gt;30&lt;/strong&gt;′)=&lt;strong&gt;0&lt;/strong&gt;–’&lt;strong&gt;2005&lt;/strong&gt;-&lt;strong&gt;11&lt;/strong&gt;-&lt;strong&gt;30&lt;/strong&gt;′生成的id
   应改为:
   select id from t where name like ‘abc%’
   select id from t where createdate&amp;gt;=’&lt;strong&gt;2005&lt;/strong&gt;-&lt;strong&gt;11&lt;/strong&gt;-&lt;strong&gt;30&lt;/strong&gt;′ and createdate&amp;lt;’&lt;strong&gt;2005&lt;/strong&gt;-&lt;strong&gt;12&lt;/strong&gt;-&lt;strong&gt;1&lt;/strong&gt;′&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10&lt;/strong&gt;.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11&lt;/strong&gt;.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12&lt;/strong&gt;.不要写一些没有意义的查询，如需要生成一个空表结构：
   select col1,col2 into #t from t where &lt;strong&gt;1&lt;/strong&gt;=&lt;strong&gt;0&lt;/strong&gt;
   这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：
   create table #t(…)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13&lt;/strong&gt;.很多时候用 exists 代替 in 是一个好的选择：
   select num from a where num in(select num from b)
   用下面的语句替换：
   select num from a where exists(select &lt;strong&gt;1&lt;/strong&gt; from b where num=a.num)**
**
 &lt;strong&gt;14&lt;/strong&gt;.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15&lt;/strong&gt;.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16&lt;/strong&gt;.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17&lt;/strong&gt;.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18&lt;/strong&gt;.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19&lt;/strong&gt;.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20&lt;/strong&gt;.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21&lt;/strong&gt;.避免频繁创建和删除临时表，以减少系统表资源的消耗。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt;.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt;.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24&lt;/strong&gt;.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt;.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26&lt;/strong&gt;.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27&lt;/strong&gt;.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28&lt;/strong&gt;.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29&lt;/strong&gt;.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30&lt;/strong&gt;.尽量避免大事务操作，提高系统并发能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查询速度慢的原因：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;、I/O吞吐量小，形成了瓶颈效应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;、没有创建计算列导致查询不优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;、内存不足&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;、网络速度慢&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;、查询出的数据量过大（可以采用多次查询，其他的方法降低数据量）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9&lt;/strong&gt;、返回了不必要的行和列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10&lt;/strong&gt;、查询语句不好，没有优化&lt;/p&gt;

&lt;p&gt;可以通过如下方法来优化查询&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;、把数据、日志、索引放到不同的I/O设备上，增加读取速度，以前可以将Tempdb应放在RAID0上，SQL2000不在支持。数据量（尺寸）越大，提高I/O越重要.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;、纵向、横向分割表，减少表的尺寸(sp_spaceuse)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;、升级硬件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;、根据查询条件,建立索引,优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好（参照索引的创建）,不要对有限的几个值的字段建单一索引如性别字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;、提高网速;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;、扩大服务器的内存,Windows  2000和SQL  server  2000能支持4-8G的内存。配置虚拟内存：虚拟内存大小应基于计算机上并发运行的服务进行配置。运行  Microsoft  SQL  Server?  &lt;strong&gt;2000&lt;/strong&gt;  时，可考虑将虚拟内存大小设置为计算机中安装的物理内存的  &lt;strong&gt;1.5&lt;/strong&gt;  倍。如果另外安装了全文检索功能，并打算运行  Microsoft  搜索服务以便执行全文索引和查询，可考虑：将虚拟内存大小配置为至少是计算机中安装的物理内存的  &lt;strong&gt;3&lt;/strong&gt;  倍。将  SQL  Server  max  server  memory  服务器配置选项配置为物理内存的  &lt;strong&gt;1.5&lt;/strong&gt;  倍（虚拟内存大小设置的一半）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;、增加服务器CPU个数;但是必须明白并行处理串行处理更需要资源例如内存。使用并行还是串行程是MsSQL自动评估选择的。单个任务分解成多个任务，就可以在处理器上运行。例如耽搁查询的排序、连接、扫描和GROUP  BY字句同时执行，SQL  SERVER根据系统的负载情况决定最优的并行等级，复杂的需要消耗大量的CPU的查询最适合并行处理。但是更新操作UPDATE,INSERT， DELETE还不能并行处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;、如果是使用like进行查询的话，简单的使用index是不行的，但是全文索引，耗空间。  like  ‘a%’  使用索引  like  ‘%a’  不使用索引用  like  ‘%a%’  查询时，查询耗时和字段值总长度成正比,所以不能用CHAR类型，而是VARCHAR。对于字段的值很长的建全文索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9&lt;/strong&gt;、DB  Server  和APPLication  Server  分离；OLTP和OLAP分离&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10&lt;/strong&gt;、分布式分区视图可用于实现数据库服务器联合体。联合体是一组分开管理的服务器，但它们相互协作分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层  Web  站点的处理需要。有关更多信息，参见设计联合数据库服务器。（参照SQL帮助文件’分区视图’）
  a、在实现分区视图之前，必须先水平分区表
  b、在创建成员表后，在每个成员服务器上定义一个分布式分区视图，并且每个视图具有相同的名称。这样，引用分布式分区视图名的查询可以在任何一个成员服务器上运行。系统操作如同每个成员服务器上都有一个原始表的复本一样，但其实每个服务器上只有一个成员表和一个分布式分区视图。数据的位置对应用程序是透明的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11&lt;/strong&gt;、重建索引  DBCC  REINDEX  ,DBCC  INDEXDEFRAG,收缩数据和日志  DBCC  SHRINKDB,DBCC  SHRINKFILE.  设置自动收缩日志.对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。  在T-sql的写法上有很大的讲究，下面列出常见的要点：首先，DBMS处理查询计划的过程是这样的：
  &lt;strong&gt;1&lt;/strong&gt;、  查询语句的词法、语法检查   &lt;br /&gt;
  &lt;strong&gt;2&lt;/strong&gt;、  将语句提交给DBMS的查询优化器
  &lt;strong&gt;3&lt;/strong&gt;、  优化器做代数优化和存取路径的优化
  &lt;strong&gt;4&lt;/strong&gt;、  由预编译模块生成查询规划
  &lt;strong&gt;5&lt;/strong&gt;、  然后在合适的时间提交给系统处理执行
  &lt;strong&gt;6&lt;/strong&gt;、  最后将执行结果返回给用户其次，看一下SQL  SERVER的数据存放的结构：一个页面的大小为8K(&lt;strong&gt;8060&lt;/strong&gt;)字节，8个页面为一个盘区，按照B树存放。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12&lt;/strong&gt;、Commit和rollback的区别  Rollback:回滚所有的事物。  Commit:提交当前的事物.  没有必要在动态SQL里写事物，如果要写请写在外面如：  begin  tran  exec(@s)  commit  trans  或者将动态SQL  写成函数或者存储过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13&lt;/strong&gt;、在查询Select语句中用Where字句限制返回的行数,避免表扫描,如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表,后果严重。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14&lt;/strong&gt;、SQL的注释申明对执行没有任何影响&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15&lt;/strong&gt;、尽可能不使用游标，它占用大量的资源。如果需要row-by-row地执行，尽量采用非光标技术,如：在客户端循环，用临时表，Table变量，用子查询，用Case语句等等。游标可以按照它所支持的提取选项进行分类：  只进  必须按照从第一行到最后一行的顺序提取行。FETCH  NEXT  是唯一允许的提取操作,也是默认方式。可滚动性  可以在游标中任何地方随机提取任意行。游标的技术在SQL2000下变得功能很强大，他的目的是支持循环。
有四个并发选项
READ_ONLY：不允许通过游标定位更新(Update)，且在组成结果集的行中没有锁。
OPTIMISTIC  WITH  valueS:乐观并发控制是事务控制理论的一个标准部分。乐观并发控制用于这样的情形，即在打开游标及更新行的间隔中，只有很小的机会让第二个用户更新某一行。当某个游标以此选项打开时，没有锁控制其中的行，这将有助于最大化其处理能力。如果用户试图修改某一行，则此行的当前值会与最后一次提取此行时获取的值进行比较。如果任何值发生改变，则服务器就会知道其他人已更新了此行，并会返回一个错误。如果值是一样的，服务器就执行修改。  选择这个并发选项OPTIMISTIC  WITH  ROW  VERSIONING:此乐观并发控制选项基于行版本控制。使用行版本控制，其中的表必须具有某种版本标识符，服务器可用它来确定该行在读入游标后是否有所更改。
在  SQL  Server  中，这个性能由  timestamp  数据类型提供，它是一个二进制数字，表示数据库中更改的相对顺序。每个数据库都有一个全局当前时间戳值：&lt;strong&gt;@@DBTS&lt;/strong&gt;。每次以任何方式更改带有  timestamp  列的行时，SQL  Server  先在时间戳列中存储当前的  &lt;strong&gt;@@DBTS&lt;/strong&gt;  值，然后增加  &lt;strong&gt;@@DBTS&lt;/strong&gt;  的值。如果某  个表具有  timestamp  列，则时间戳会被记到行级。服务器就可以比较某行的当前时间戳值和上次提取时所存储的时间戳值，从而确定该行是否已更新。服务器不必比较所有列的值，只需比较  timestamp  列即可。如果应用程序对没有  timestamp  列的表要求基于行版本控制的乐观并发，则游标默认为基于数值的乐观并发控制。
SCROLL  LOCKS  这个选项实现悲观并发控制。在悲观并发控制中，在把数据库的行读入游标结果集时，应用程序将试图锁定数据库行。在使用服务器游标时，将行读入游标时会在其上放置一个更新锁。如果在事务内打开游标，则该事务更新锁将一直保持到事务被提交或回滚；当提取下一行时，将除去游标锁。如果在事务外打开游标，则提取下一行时，锁就被丢弃。因此，每当用户需要完全的悲观并发控制时，游标都应在事务内打开。更新锁将阻止任何其它任务获取更新锁或排它锁，从而阻止其它任务更新该行。
然而，更新锁并不阻止共享锁，所以它不会阻止其它任务读取行，除非第二个任务也在要求带更新锁的读取。滚动锁根据在游标定义的  SELECT  语句中指定的锁提示，这些游标并发选项可以生成滚动锁。滚动锁在提取时在每行上获取，并保持到下次提取或者游标关闭，以先发生者为准。下次提取时，服务器为新提取中的行获取滚动锁，并释放上次提取中行的滚动锁。滚动锁独立于事务锁，并可以保持到一个提交或回滚操作之后。如果提交时关闭游标的选项为关，则  COMMIT  语句并不关闭任何打开的游标，而且滚动锁被保留到提交之后，以维护对所提取数据的隔离。所获取滚动锁的类型取决于游标并发选项和游标  SELECT  语句中的锁提示。
锁提示  只读  乐观数值  乐观行版本控制  锁定无提示  未锁定  未锁定  未锁定  更新  NOLOCK  未锁定  未锁定  未锁定  未锁定  HOLDLOCK  共享  共享  共享  更新  UPDLOCK  错误  更新  更新  更新  TABLOCKX  错误  未锁定  未锁定  更新其它  未锁定  未锁定  未锁定  更新  *指定  NOLOCK  提示将使指定了该提示的表在游标内是只读的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16&lt;/strong&gt;、用Profiler来跟踪查询，得到查询所需的时间，找出SQL的问题所在;用索引优化器优化索引&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17&lt;/strong&gt;、注意UNion和UNion  all  的区别。UNION  all好&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18&lt;/strong&gt;、注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19&lt;/strong&gt;、查询时不要返回不需要的行、列&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20&lt;/strong&gt;、用sp_configure  ‘query  governor  cost  limit’或者SET  QUERY_GOVERNOR_COST_LIMIT来限制查询消耗的资源。当评估查询消耗的资源超出限制时，服务器自动取消查询,在查询之前就扼杀掉。 SET  LOCKTIME设置锁的时间&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21&lt;/strong&gt;、用select  top  &lt;strong&gt;100&lt;/strong&gt;  /  &lt;strong&gt;10&lt;/strong&gt;  Percent  来限制用户返回的行数或者SET  ROWCOUNT来限制操作的行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22&lt;/strong&gt;、在SQL2000以前，一般不要用如下的字句 “IS  NULL”,  “ &amp;lt;&amp;gt; “,  “!=”,  “!&amp;gt; “,  “! &amp;lt;”,  “NOT”,  “NOT  EXISTS”,  “NOT  IN”,  “NOT  LIKE”,  and  “LIKE  ‘%500’“，因为他们不走索引全是表扫描。
也不要在WHere字句中的列名加函数，如Convert，substring等,如果必须用函数的时候，创建计算列再创建索引来替代.还可以变通写法：WHERE  SUBSTRING(firstname,&lt;strong&gt;1&lt;/strong&gt;,&lt;strong&gt;1&lt;/strong&gt;)  =  ‘m’改为WHERE  firstname  like  ‘m%’（索引扫描），一定要将函数和列名分开。并且索引不能建得太多和太大。
NOT  IN会多次扫描表，使用EXISTS、NOT  EXISTS  ，IN  ,  LEFT  OUTER  JOIN  来替代，特别是左连接,而Exists比IN更快，最慢的是NOT操作.如果列的值含有空，以前它的索引不起作用，现在2000的优化器能够处理了。相同的是IS  NULL，“NOT”,  “NOT  EXISTS”,  “NOT  IN”能优化她，而” &amp;lt;&amp;gt; ”等还是不能优化，用不到索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23&lt;/strong&gt;、使用Query  Analyzer，查看SQL语句的查询计划和评估分析是否是优化的SQL。一般的20%的代码占据了80%的资源，我们优化的重点是这些慢的地方。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24&lt;/strong&gt;、如果使用了IN或者OR等时发现查询没有走索引，使用显示申明指定索引：  SELECT  *  FROM  PersonMember  (INDEX  =  IX_Title)  WHERE  processid  IN  (‘男’，‘女’)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25&lt;/strong&gt;、将需要查询的结果预先计算好放在表中，查询的时候再SELECT。这在SQL7.0以前是最重要的手段。例如医院的住院费计算。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26&lt;/strong&gt;、MIN()  和  MAX()能使用到合适的索引&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27&lt;/strong&gt;、数据库有一个原则是代码离数据越近越好，所以优先选择Default,依次为Rules,Triggers,  Constraint（约束如外健主健CheckUNIQUE……,数据类型的最大长度等等都是约束）,Procedure.这样不仅维护工作小，编写程序质量高，并且执行的速度快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28&lt;/strong&gt;、如果要插入大的二进制值到Image列，使用存储过程，千万不要用内嵌INsert来插入(不知JAVA是否)。因为这样应用程序首先将二进制值转换成字符串（尺寸是它的两倍），服务器受到字符后又将他转换成二进制值.存储过程就没有这些动作:  方法：Create  procedure  p_insert  as  insert  into  table(Fimage)  values  (@image),  在前台调用这个存储过程传入二进制参数，这样处理速度明显改善。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29&lt;/strong&gt;、Between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。  select  *  from  chineseresume  where  title  in  (‘男’,’女’)  Select  *  from  chineseresume  where  between  ‘男’  and  ‘女’  是一样的。由于in会在比较多次，所以有时会慢些。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30&lt;/strong&gt;、在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31&lt;/strong&gt;、不要建没有作用的事物例如产生报表时，浪费资源。只有在必要使用事物时使用它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;32&lt;/strong&gt;、用OR的字句可以分解成多个查询，并且通过UNION  连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNION  all执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;33&lt;/strong&gt;、尽量少用视图，它的效率低。对视图操作比直接对表操作慢,可以用stored  procedure来代替她。特别的是不要用视图嵌套,嵌套视图增加了寻找原始资料的难度。我们看视图的本质：它是存放在服务器上的被优化好了的已经产生了查询规划的SQL。对单个表检索数据时，不要使用指向多个表的视图，直接从表检索或者仅仅包含这个表的视图上读，否则增加了不必要的开销,查询受到干扰.为了加快视图的查询，MsSQL增加了视图索引的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34&lt;/strong&gt;、没有必要时不要用DISTINCT和ORDER  BY，这些动作可以改在客户端执行。它们增加了额外的开销。这同UNION  和UNION  ALL一样的道理。  SELECT  top  &lt;strong&gt;20&lt;/strong&gt;  ad.companyname,comid,position,ad.referenceid,worklocation,  convert(varchar(&lt;strong&gt;10&lt;/strong&gt;),ad.postDate,&lt;strong&gt;120&lt;/strong&gt;)  as  postDate1,workyear,degreedescription  FROM  jobcn_query.dbo.COMPANYAD_query  ad  where  referenceID  in(‘JCNAD00329667’,’JCNAD132168’,’JCNAD00337748’,’JCNAD00338345’,’JCNAD00333138’,’JCNAD00303570’,  ‘JCNAD00303569’,’JCNAD00303568’,’JCNAD00306698’,’JCNAD00231935’,’JCNAD00231933’,’JCNAD00254567’,  ‘JCNAD00254585’,’JCNAD00254608’,’JCNAD00254607’,’JCNAD00258524’,’JCNAD00332133’,’JCNAD00268618’,  ‘JCNAD00279196’,’JCNAD00268613’)  order  by  postdate  desc&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;35&lt;/strong&gt;、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;36&lt;/strong&gt;、当用SELECT  INTO时，它会锁住系统表(sysobjects，sysindexes等等)，阻塞其他的连接的存取。创建临时表时用显示申明语句，而不是 select  INTO.  drop  table  t_lxh  begin  tran  select  *  into  t_lxh  from  chineseresume  where  name  =  ‘XYZ’  –commit  在另一个连接中SELECT  *  from  sysobjects可以看到  SELECT  INTO  会锁住系统表，Create  table  也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;37&lt;/strong&gt;、一般在GROUP  BY  个HAVING字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：select  的Where字句选择所有合适的行，Group  By用来分组个统计行，Having字句用来剔除多余的分组。这样Group  By  个Having的开销小，查询快.对于大的数据行进行分组和Having十分消耗资源。如果Group  BY的目的不包括计算，只是分组，那么用Distinct更快&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;38&lt;/strong&gt;、一次更新多条记录比分多次更新每次一条快,就是说批处理好&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;39&lt;/strong&gt;、少用临时表，尽量用结果集和Table类性的变量来代替它,Table  类型的变量比临时表好&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;40&lt;/strong&gt;、在SQL2000下，计算字段是可以索引的，需要满足的条件如下：&lt;/p&gt;

&lt;p&gt;a、计算字段的表达是确定的
 b、不能用在TEXT,Ntext，Image数据类型
 c、必须配制如下选项  ANSI_NULLS  =  ON,  ANSI_PADDINGS  =  ON,  …….&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;41&lt;/strong&gt;、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的 SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。以前由于SQL  SERVER对复杂的数学计算不支持，所以不得不将这个工作放在其他的层上而增加网络的开销。SQL2000支持UDFs,现在支持复杂的数学计算，函数的返回值不要太大，这样的开销很大。用户自定义函数象光标一样执行的消耗大量的资源，如果返回大的结果采用存储过程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;42&lt;/strong&gt;、不要在一句话里再三的使用相同的函数，浪费资源,将结果放在变量里再调用更快&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;43&lt;/strong&gt;、SELECT  COUNT(*)的效率教低，尽量变通他的写法，而EXISTS快.同时请注意区别：  select  count(Field  of  null)  from  Table  和  select  count(Field  of  NOT  null)  from  Table  的返回值是不同的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;44&lt;/strong&gt;、当服务器的内存够多时，配制线程数量  =  最大连接数+&lt;strong&gt;5&lt;/strong&gt;，这样能发挥最大的效率；否则使用  配制线程数量 &amp;lt;最大连接数启用SQL  SERVER的线程池来解决,如果还是数量  =  最大连接数+&lt;strong&gt;5&lt;/strong&gt;，严重的损害服务器的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;45&lt;/strong&gt;、按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;46&lt;/strong&gt;、通过SQL  Server  Performance  Monitor监视相应硬件的负载  Memory:  Page  Faults  /  sec计数器如果该值偶尔走高，表明当时有线程竞争内存。如果持续很高，则内存可能是瓶颈。  Process:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;、%  DPC  Time  指在范例间隔期间处理器用在缓延程序调用(DPC)接收和提供服务的百分比。(DPC  正在运行的为比标准间隔优先权低的间隔)。  由于  DPC  是以特权模式执行的，DPC  时间的百分比为特权时间  百分比的一部分。这些时间单独计算并且不属于间隔计算总数的一部  分。这个总数显示了作为实例时间百分比的平均忙时。
  &lt;strong&gt;2&lt;/strong&gt;、%Processor  Time计数器　如果该参数值持续超过95%，表明瓶颈是CPU。可以考虑增加一个处理器或换一个更快的处理器。
  &lt;strong&gt;3&lt;/strong&gt;、%  Privileged  Time  指非闲置处理器时间用于特权模式的百分比。(特权模式是为操作系统组件和操纵硬件驱动程序而设计的一种处理模式。它允许直接访问硬件和所有内存。另一种模式为用户模式，它是一种为应用程序、环境分系统和整数分系统设计的一种有限处理模式。操作系统将应用程序线程转换成特权模式以访问操作系统服务)。  特权时间的  %  包括为间断和  DPC  提供服务的时间。特权时间比率高可能是由于失败设备产生的大数量的间隔而引起的。这个计数器将平均忙时作为样本时间的一部分显示。
  &lt;strong&gt;4&lt;/strong&gt;、%  User  Time表示耗费CPU的数据库操作，如排序，执行aggregate  functions等。如果该值很高，可考虑增加索引，尽量使用简单的表联接，水平分割大表格等方法来降低该值。  Physical  Disk:  Curretn  Disk  Queue  Length计数器该值应不超过磁盘数的1.&lt;strong&gt;5&lt;/strong&gt;~2倍。要提高性能，可增加磁盘。  SQLServer:Cache  Hit  Ratio计数器该值越高越好。如果持续低于80%，应考虑增加内存。  注意该参数值是从SQL  Server启动后，就一直累加记数，所以运行经过一段时间后，该值将不能反映系统当前值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;47&lt;/strong&gt;、分析select  emp_name  form  employee  where  salary  &amp;gt;  &lt;strong&gt;3000&lt;/strong&gt;  在此语句中若salary是Float类型的，则优化器对其进行优化为Convert(float,&lt;strong&gt;3000&lt;/strong&gt;)，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。同样字符和整型数据的转换。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--查找所有索引
SELECT  'dbcc showcontig (' + CONVERT(VARCHAR(20), i.id) + ',' + -- table id
CONVERT(VARCHAR(20), i.indid) + ')--' + --index id
OBJECT_NAME(i.id) + '.' + -- table name
i.name--index name
FROM    sysobjects o
        INNER JOIN sysindexes i ON ( o.id = i.id )
WHERE   o.type = 'U'
        AND i.indid &amp;lt; 2
        AND i.id = OBJECT_ID(o.name)
ORDER BY OBJECT_NAME(i.id), i.indid


--结果
dbcc showcontig (2052202361,1)--AddBusiness.PK_AddBusiness
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;何时需要重建索引：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DBCC showcontig(‘Send’)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mianshiti/0708/04162141-e255aa29d6624144bbe743e11591d2b4.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">性能不理想的系统： 应用程序的负载确实超过了服务器的实际处理能力外 系统存在大量的SQL语句需要优化 优化原则一：SQL语句越简单越好 不要有超过5个以上的表连接（JOIN） 考虑使用临时表或表变量存放中间结果。 少用子查询 视图嵌套不要过深,一般视图嵌套不要超过2个为宜。 使用推荐： 连接的表越多，其编译的时间和连接的开销也越大，性能越不好控制。 最好是把连接拆开成较小的几个部分逐个顺序执行。 优先执行那些能够大量减少结果的连接。 拆分的好处不仅仅是减少SQL Server优化的时间，更使得SQL语句能够以你可以预测的方式和顺序执行。 如果一定需要连接很多表才能得到数据，那么很可能意味着设计上的缺陷。 outer join 使用的缺点 连接是outer join，非常不好。因为outer join意味着必须对左表或右表查询所有行。如果表很大而没有相应的where语句，那么outer join很容易导致table scan或index scan。 要尽量使用inner join避免scan整个表。 优化建议： 使用临时表存放t1表的结果,能大大减少logical reads（或返回行数）的操作要优先执行。 仔细分析语句，你会发现where中的条件全是针对表t1的，所以直接使用上面的where子句查询表t1，然后把结果存放再临时表＃t1中： Select t1….. into #tt1 from t1 where…(和上面的where一样) 再把＃tt1和其他表进行连接: Select #t1… Left outer join … Left outer join… 修改 like 程序，去掉前置百分号。like语句却因为前置百分号而无法使用索引 从系统设计的角度修改语句，去掉outer join。 考虑组合索引或覆盖索引消除 clustered index scan。 上面1和2点建议立即消除了worktable，性能提高了几倍以上，效果非常明显。 限制结果集 要尽量减少返回的结果行，包括行数和字段列数。 返回的结果越大，意味着相应的SQL语句的logical reads 就越大，对服务器的性能影响就越甚。 一个很不好的设计就是返回表的所有数据： Select * from tablename 即使表很小也会导致并发问题。更坏的情况是，如果表有上百万行的话，那后果将是灾难性的。 它不但可能带来极重的磁盘IO，更有可能把数据库缓冲区中的其他缓存数据挤出，使得这些数据下次必须再从磁盘读取。 必须设计良好的SQL语句，使得其有where语句或TOP语句来限制结果集大小。 合理的表设计 SQL Server 2005将支持表分区技术。利用表分区技术可以实现数据表的流动窗口功能。 在流动窗口中可以轻易的把历史数据移出，把新的数据加入，从而使表的大小基本保持稳定。 另外，表的设计未必需要非常范式化。有一定的字段冗余可以增加SQL语句的效率，减少JOIN的数目，提高语句的执行速度。 OLAP和OLTP模块要分开 OLAP和OLTP类型的语句是截然不同的。前者往往需要扫描整个表做统计分析，索引对这样的语句几乎没有多少用处。 索引只能够加快那些如sum，group by之类的聚合运算。因为这个原因，几乎很难对OLAP类型的SQL语句进行优化。 而OLTP语句则只需要访问表的很小一部分数据，而且这些数据往往可以从内存缓存中得到。 为了避免OLAP 和OLTP语句相互影响，这两类模块需要分开运行在不同服务器上。 因为OLAP语句几乎都是读取数据，没有更新和写入操作，所以一个好的经验是配置一台standby 服务器，然后OLAP只访问standby服务器。 使用存储过程 可以考虑使用存储过程封装那些复杂的SQL语句或商业逻辑，这样做有几个好处。 一是存储过程的执行计划可以被缓存在内存中较长时间，减少了重新编译的时间。 二是存储过程减少了客户端和服务器的繁复交互。 三是如果程序发布后需要做某些改变你可以直接修改存储过程而不用修改程序，避免需要重新安装部署程序。 索引优化 很多数据库系统性能不理想是因为系统没有经过整体优化，存在大量性能低下的SQL 语句。 这类SQL语句性能不好的首要原因是缺乏高效的索引。 没有索引除了导致语句本身运行速度慢外，更是导致大量的磁盘读写操作，使得整个系统性能都受之影响而变差。 解决这类系统的首要办法是优化这些没有索引或索引不够好的SQL语句。 创建索引的关键 优化SQL语句的关键是尽可能减少语句的logical reads。 这里说的logical reads是指语句执行时需要访问的单位为8K的数据页总数。 logical reads 越少，其需要的内存和CPU时间也就越少，语句执行速度就越快。 不言而喻，索引的最大好处是它可以极大减少SQL语句的logical reads数目，从而极大减少语句的执行时间。 创建索引的关键是索引要能够大大减少语句的logical reads。一个索引好不好，主要看它减少的logical reads多不多。 运行set statistics io命令可以得到SQL语句的logical reads信息。 set statistics io on select au_id,au_lname ,au_fname from pubs..authors where au_lname =’Green’ set statistics io on 如果Logical reads很大，而返回的行数很少，也即两者相差较大，那么往往意味者语句需要优化。 Logical reads中包含该语句从内存数据缓冲区中访问的页数和从物理磁盘读取的页数。 而physical reads表示那些没有驻留在内存缓冲区中需要从磁盘读取的数据页。 Read-ahead reads是SQL Server为了提高性能而产生的预读。预读可能会多读取一些数据。 优化的时候我们主要关注Logical Reads就可以了。 注意如果physical Reads或Read-ahead reads很大，那么往往意味着语句的执行时间（duration）里面会有一部分耗费在等待物理磁盘IO上。 二、单字段索引，组合索引和覆盖索引 单字段索引是指只有一个字段的索引，而组合索引指有多个字段构成的索引。 1． 对出现在where子句中的字段加索引 set statistics profile on set statistics io on go select …. from tb where … go set statistics profile off set statistics io off set statistics profile命令将输出语句的执行计划。 也许你会问，为什么不用SET SHOWPLAN_ALL呢？使用SET SHOWPLAN_ALL也是可以的。 不过set statistics profile输出的是SQL 语句的运行时候真正使用的执行计划， 而SET SHOWPLAN_ALL输出的是预计（Estimate）的执行计划。 使用SET SHOWPLAN_ALL是后面的语句并不会真正运行。 用了Table Scan，也就是对整个表进行了全表扫描。全表扫描的性能通常是很差的，要尽量避免。 如果上面的select语句是数据库系统经常运行的关键语句， 那么应该对它创建相应的索引。 创建索引的技巧之一是对经常出现在where条件中的字段创建索引 Table Scan也变成了Index Seek，性能极大提高 设法避免Table scan或Index scan是优化SQL 语句使用的常用技巧。通常Index Seek需要的logical reads比前两者要少得多。 2．组合索引 如果where语句中有多个字段，那么可以考虑创建组合索引。 组合索引中字段的顺序是非常重要的，越是唯一的字段越是要靠前。 另外，无论是组合索引还是单个列的索引，尽量不要选择那些唯一性很低的字段。 比如说，在只有两个值0和1的字段上建立索引没有多大意义。 所以如果对单字段进行索引，建议使用set statistics profile来验证索引确实被充分使用。logical reads越少的索引越好。 3．覆盖索引 覆盖索引能够使得语句不需要访问表仅仅访问索引就能够得到所有需要的数据。 因为聚集索引叶子节点就是数据所以无所谓覆盖与否，所以覆盖索引主要是针对非聚集索引而言。 执行计划中除了index seek外，还有一个Bookmark Lookup关键字。 Bookmark Lookup表示语句在访问索引后还需要对表进行额外的Bookmark Lookup操作才能得到数据。 也就是说为得到一行数据起码有两次IO，一次访问索引，一次访问基本表。 如果语句返回的行数很多，那么Bookmark Lookup操作的开销是很大的。 覆盖索引能够避免昂贵的Bookmark Lookup操作，减少IO的次数，提高语句的性能。 覆盖索引需要包含select子句和WHERE子句中出现的所有字段。Where语句中的字段在前面，select中的在后面。 logical reads，是大大减少了。Bookmark Lookup操作也消失了。所以创建覆盖索引是减少logical reads提升语句性能的非常有用的优化技巧。 实际上索引的创建原则是比较复杂的。有时候你无法在索引中包含了Where子句中所有的字段。 在考虑索引是否应该包含一个字段时，应考虑该字段在语句中的作用。 比如说如果经常以某个字段作为where条件作精确匹配返回很少的行，那么就绝对值得为这个字段建立索引。 再比如说，对那些非常唯一的字段如主键和外键，经常出现在group by，order by中的字段等等都值得创建索引。 问题1，是否值得在identity字段上建立聚集索引。 答案取决于identity 字段如何在语句中使用。如果你经常根据该字段搜索返回很少的行，那么在其上建立索引是值得的。 反之如果identity字段根本很少在语句中使用，那么就不应该对其建立任何索引。 问题2，一个表应该建立多少索引合适。 如果表的80％以上的语句都是读操作，那么索引可以多些。但是不要太多。 特别是不要对那些更新频繁的表其建立很多的索引。很少表有超过5个以上的索引。 过多的索引不但增加其占用的磁盘空间，也增加了SQL Server 维护索引的开销。 问题4：为什么SQL Server 在执行计划中没有使用你认为应该使用的索引？原因是多样的。 一种原因是该语句返回的结果超过了表的20％数据，使得SQL Server 认为scan比seek更有效。 另一种原因可能是表字段的statistics过期了，不能准确反映数据的分布情况。 你可以使用命令UPDATE STATISTICS tablename with FULLSCAN来更新它。 只有同步的准确的statistics才能保证SQL Server 产生正确的执行计划。 过时的老的statistics常会导致SQL Server生成不够优化的甚至愚蠢的执行计划。 所以如果你的表频繁更新，而你又觉得和之相关的SQL语句运行缓慢，不妨试试UPDATE STATISTIC with FULLSCAN 语句。 问题5、什么使用聚集索引，什么时候使用非聚集索引 在SQL Server 中索引有聚集索引和非聚集索引两种。它们的主要差别是前者的索引叶子就是数据本身，而后者的叶子节点包含的是指向数据的书签（即数据行号或聚集索引的key）。 对一个表而言聚集索引只能有一个，而非聚集索引可以有多个。 只是聚集索引没有Bookmark Lookup操作。 什么时候应该使用聚集索引? 什么时候使用非聚集索引? 取决于应用程序的访问模式。 我的建议是在那些关键的字段上使用聚集索引。一个表一般都需要建立一个聚集索引。 对于什么时候使用聚集索引，SQL Server 2000联机手册中有如下描述： 在创建聚集索引之前，应先了解您的数据是如何被访问的。可考虑将聚集索引用于： 包含大量非重复值的列。 使用下列运算符返回一个范围值的查询：BETWEEN、&amp;gt;、&amp;gt;=、&amp;lt; 和 &amp;lt;=。 被连续访问的列。 返回大型结果集的查询。 经常被使用联接或 GROUP BY 子句的查询访问的列；一般来说，这些是外键列。 对 ORDER BY 或 GROUP BY 子句中指定的列进行索引，可以使 SQL Server 不必对数据进行排序，因为这些行已经排序。这样可以提高查询性能。 OLTP 类型的应用程序，这些程序要求进行非常快速的单行查找（一般通过主键）。应在主键上创建聚集索引。 聚集索引不适用于： 频繁更改的列 这将导致整行移动（因为 SQL Server 必须按物理顺序保留行中的数据值）。这一点要特别注意，因为在大数据量事务处理系统中数据是易失的。 宽键 来自聚集索引的键值由所有非聚集索引作为查找键使用，因此存储在每个非聚集索引的叶条目内。 总结： 如何使一个性能缓慢的系统运行更快更高效，不但需要整体分析数据库系统，找出系统的性能瓶颈，更需要优化数据库系统发出的SQL 语句。 一旦找出关键的SQL 语句并加与优化，性能问题就会迎刃而解。 《 数据库技术内幕 》 处理百万级以上的数据提高查询速度的方法： 1.应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 2.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 3.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0 ** **4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20 ** **5.下面的查询也将导致全表扫描：(不能前置百分号) select id from t where name like ‘%abc%’ 若要提高效率，可以考虑全文检索。 6.in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and **3 ** select xx,phone FROM send a JOIN ( select ‘13891030091’ phone union select ‘13992085916’ ………… UNION SELECT ‘13619100234’ ) b on a.Phone=b.phone –替代下面 很多数据隔开的时候 in(‘13891030091’,’13992085916’,’13619100234’…………) 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 ** **9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&amp;gt;=’2005-11-30′ and createdate&amp;lt;’2005-12-1′ 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使 用，并且应尽可能的让字段顺序与索引顺序相一致。 12.不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) 13.很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)** ** 14.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 15.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。 16.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 17.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会 逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 18.尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 19.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 20.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 21.避免频繁创建和删除临时表，以减少系统表资源的消耗。 22.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使 用导出表。 23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 29.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 30.尽量避免大事务操作，提高系统并发能力。 查询速度慢的原因： 1、没有索引或者没有用到索引(这是查询慢最常见的问题，是程序设计的缺陷) 2、I/O吞吐量小，形成了瓶颈效应。 3、没有创建计算列导致查询不优化。 4、内存不足 5、网络速度慢 6、查询出的数据量过大（可以采用多次查询，其他的方法降低数据量） 7、锁或者死锁(这也是查询慢最常见的问题，是程序设计的缺陷) 8、sp_lock,sp_who,活动的用户查看,原因是读写竞争资源。 9、返回了不必要的行和列 10、查询语句不好，没有优化 可以通过如下方法来优化查询 1、把数据、日志、索引放到不同的I/O设备上，增加读取速度，以前可以将Tempdb应放在RAID0上，SQL2000不在支持。数据量（尺寸）越大，提高I/O越重要. 2、纵向、横向分割表，减少表的尺寸(sp_spaceuse) 3、升级硬件 4、根据查询条件,建立索引,优化索引、优化访问方式，限制结果集的数据量。注意填充因子要适当（最好是使用默认值0）。索引应该尽量小，使用字节数小的列建索引好（参照索引的创建）,不要对有限的几个值的字段建单一索引如性别字段 5、提高网速; 6、扩大服务器的内存,Windows 2000和SQL server 2000能支持4-8G的内存。配置虚拟内存：虚拟内存大小应基于计算机上并发运行的服务进行配置。运行 Microsoft SQL Server? 2000 时，可考虑将虚拟内存大小设置为计算机中安装的物理内存的 1.5 倍。如果另外安装了全文检索功能，并打算运行 Microsoft 搜索服务以便执行全文索引和查询，可考虑：将虚拟内存大小配置为至少是计算机中安装的物理内存的 3 倍。将 SQL Server max server memory 服务器配置选项配置为物理内存的 1.5 倍（虚拟内存大小设置的一半）。 7、增加服务器CPU个数;但是必须明白并行处理串行处理更需要资源例如内存。使用并行还是串行程是MsSQL自动评估选择的。单个任务分解成多个任务，就可以在处理器上运行。例如耽搁查询的排序、连接、扫描和GROUP BY字句同时执行，SQL SERVER根据系统的负载情况决定最优的并行等级，复杂的需要消耗大量的CPU的查询最适合并行处理。但是更新操作UPDATE,INSERT， DELETE还不能并行处理。 8、如果是使用like进行查询的话，简单的使用index是不行的，但是全文索引，耗空间。 like ‘a%’ 使用索引 like ‘%a’ 不使用索引用 like ‘%a%’ 查询时，查询耗时和字段值总长度成正比,所以不能用CHAR类型，而是VARCHAR。对于字段的值很长的建全文索引。 9、DB Server 和APPLication Server 分离；OLTP和OLAP分离 10、分布式分区视图可用于实现数据库服务器联合体。联合体是一组分开管理的服务器，但它们相互协作分担系统的处理负荷。这种通过分区数据形成数据库服务器联合体的机制能够扩大一组服务器，以支持大型的多层 Web 站点的处理需要。有关更多信息，参见设计联合数据库服务器。（参照SQL帮助文件’分区视图’） a、在实现分区视图之前，必须先水平分区表 b、在创建成员表后，在每个成员服务器上定义一个分布式分区视图，并且每个视图具有相同的名称。这样，引用分布式分区视图名的查询可以在任何一个成员服务器上运行。系统操作如同每个成员服务器上都有一个原始表的复本一样，但其实每个服务器上只有一个成员表和一个分布式分区视图。数据的位置对应用程序是透明的。 11、重建索引 DBCC REINDEX ,DBCC INDEXDEFRAG,收缩数据和日志 DBCC SHRINKDB,DBCC SHRINKFILE. 设置自动收缩日志.对于大的数据库不要设置数据库自动增长，它会降低服务器的性能。 在T-sql的写法上有很大的讲究，下面列出常见的要点：首先，DBMS处理查询计划的过程是这样的： 1、 查询语句的词法、语法检查 2、 将语句提交给DBMS的查询优化器 3、 优化器做代数优化和存取路径的优化 4、 由预编译模块生成查询规划 5、 然后在合适的时间提交给系统处理执行 6、 最后将执行结果返回给用户其次，看一下SQL SERVER的数据存放的结构：一个页面的大小为8K(8060)字节，8个页面为一个盘区，按照B树存放。 12、Commit和rollback的区别 Rollback:回滚所有的事物。 Commit:提交当前的事物. 没有必要在动态SQL里写事物，如果要写请写在外面如： begin tran exec(@s) commit trans 或者将动态SQL 写成函数或者存储过程。 13、在查询Select语句中用Where字句限制返回的行数,避免表扫描,如果返回不必要的数据，浪费了服务器的I/O资源，加重了网络的负担降低性能。如果表很大，在表扫描的期间将表锁住，禁止其他的联接访问表,后果严重。 14、SQL的注释申明对执行没有任何影响 15、尽可能不使用游标，它占用大量的资源。如果需要row-by-row地执行，尽量采用非光标技术,如：在客户端循环，用临时表，Table变量，用子查询，用Case语句等等。游标可以按照它所支持的提取选项进行分类： 只进 必须按照从第一行到最后一行的顺序提取行。FETCH NEXT 是唯一允许的提取操作,也是默认方式。可滚动性 可以在游标中任何地方随机提取任意行。游标的技术在SQL2000下变得功能很强大，他的目的是支持循环。 有四个并发选项 READ_ONLY：不允许通过游标定位更新(Update)，且在组成结果集的行中没有锁。 OPTIMISTIC WITH valueS:乐观并发控制是事务控制理论的一个标准部分。乐观并发控制用于这样的情形，即在打开游标及更新行的间隔中，只有很小的机会让第二个用户更新某一行。当某个游标以此选项打开时，没有锁控制其中的行，这将有助于最大化其处理能力。如果用户试图修改某一行，则此行的当前值会与最后一次提取此行时获取的值进行比较。如果任何值发生改变，则服务器就会知道其他人已更新了此行，并会返回一个错误。如果值是一样的，服务器就执行修改。 选择这个并发选项OPTIMISTIC WITH ROW VERSIONING:此乐观并发控制选项基于行版本控制。使用行版本控制，其中的表必须具有某种版本标识符，服务器可用它来确定该行在读入游标后是否有所更改。 在 SQL Server 中，这个性能由 timestamp 数据类型提供，它是一个二进制数字，表示数据库中更改的相对顺序。每个数据库都有一个全局当前时间戳值：@@DBTS。每次以任何方式更改带有 timestamp 列的行时，SQL Server 先在时间戳列中存储当前的 @@DBTS 值，然后增加 @@DBTS 的值。如果某 个表具有 timestamp 列，则时间戳会被记到行级。服务器就可以比较某行的当前时间戳值和上次提取时所存储的时间戳值，从而确定该行是否已更新。服务器不必比较所有列的值，只需比较 timestamp 列即可。如果应用程序对没有 timestamp 列的表要求基于行版本控制的乐观并发，则游标默认为基于数值的乐观并发控制。 SCROLL LOCKS 这个选项实现悲观并发控制。在悲观并发控制中，在把数据库的行读入游标结果集时，应用程序将试图锁定数据库行。在使用服务器游标时，将行读入游标时会在其上放置一个更新锁。如果在事务内打开游标，则该事务更新锁将一直保持到事务被提交或回滚；当提取下一行时，将除去游标锁。如果在事务外打开游标，则提取下一行时，锁就被丢弃。因此，每当用户需要完全的悲观并发控制时，游标都应在事务内打开。更新锁将阻止任何其它任务获取更新锁或排它锁，从而阻止其它任务更新该行。 然而，更新锁并不阻止共享锁，所以它不会阻止其它任务读取行，除非第二个任务也在要求带更新锁的读取。滚动锁根据在游标定义的 SELECT 语句中指定的锁提示，这些游标并发选项可以生成滚动锁。滚动锁在提取时在每行上获取，并保持到下次提取或者游标关闭，以先发生者为准。下次提取时，服务器为新提取中的行获取滚动锁，并释放上次提取中行的滚动锁。滚动锁独立于事务锁，并可以保持到一个提交或回滚操作之后。如果提交时关闭游标的选项为关，则 COMMIT 语句并不关闭任何打开的游标，而且滚动锁被保留到提交之后，以维护对所提取数据的隔离。所获取滚动锁的类型取决于游标并发选项和游标 SELECT 语句中的锁提示。 锁提示 只读 乐观数值 乐观行版本控制 锁定无提示 未锁定 未锁定 未锁定 更新 NOLOCK 未锁定 未锁定 未锁定 未锁定 HOLDLOCK 共享 共享 共享 更新 UPDLOCK 错误 更新 更新 更新 TABLOCKX 错误 未锁定 未锁定 更新其它 未锁定 未锁定 未锁定 更新 *指定 NOLOCK 提示将使指定了该提示的表在游标内是只读的。 16、用Profiler来跟踪查询，得到查询所需的时间，找出SQL的问题所在;用索引优化器优化索引 17、注意UNion和UNion all 的区别。UNION all好 18、注意使用DISTINCT，在没有必要时不要用，它同UNION一样会使查询变慢。重复的记录在查询里是没有问题的 19、查询时不要返回不需要的行、列 20、用sp_configure ‘query governor cost limit’或者SET QUERY_GOVERNOR_COST_LIMIT来限制查询消耗的资源。当评估查询消耗的资源超出限制时，服务器自动取消查询,在查询之前就扼杀掉。 SET LOCKTIME设置锁的时间 21、用select top 100 / 10 Percent 来限制用户返回的行数或者SET ROWCOUNT来限制操作的行 22、在SQL2000以前，一般不要用如下的字句 “IS NULL”, “ &amp;lt;&amp;gt; “, “!=”, “!&amp;gt; “, “! &amp;lt;”, “NOT”, “NOT EXISTS”, “NOT IN”, “NOT LIKE”, and “LIKE ‘%500’“，因为他们不走索引全是表扫描。 也不要在WHere字句中的列名加函数，如Convert，substring等,如果必须用函数的时候，创建计算列再创建索引来替代.还可以变通写法：WHERE SUBSTRING(firstname,1,1) = ‘m’改为WHERE firstname like ‘m%’（索引扫描），一定要将函数和列名分开。并且索引不能建得太多和太大。 NOT IN会多次扫描表，使用EXISTS、NOT EXISTS ，IN , LEFT OUTER JOIN 来替代，特别是左连接,而Exists比IN更快，最慢的是NOT操作.如果列的值含有空，以前它的索引不起作用，现在2000的优化器能够处理了。相同的是IS NULL，“NOT”, “NOT EXISTS”, “NOT IN”能优化她，而” &amp;lt;&amp;gt; ”等还是不能优化，用不到索引。 23、使用Query Analyzer，查看SQL语句的查询计划和评估分析是否是优化的SQL。一般的20%的代码占据了80%的资源，我们优化的重点是这些慢的地方。 24、如果使用了IN或者OR等时发现查询没有走索引，使用显示申明指定索引： SELECT * FROM PersonMember (INDEX = IX_Title) WHERE processid IN (‘男’，‘女’) 25、将需要查询的结果预先计算好放在表中，查询的时候再SELECT。这在SQL7.0以前是最重要的手段。例如医院的住院费计算。 26、MIN() 和 MAX()能使用到合适的索引 27、数据库有一个原则是代码离数据越近越好，所以优先选择Default,依次为Rules,Triggers, Constraint（约束如外健主健CheckUNIQUE……,数据类型的最大长度等等都是约束）,Procedure.这样不仅维护工作小，编写程序质量高，并且执行的速度快。 28、如果要插入大的二进制值到Image列，使用存储过程，千万不要用内嵌INsert来插入(不知JAVA是否)。因为这样应用程序首先将二进制值转换成字符串（尺寸是它的两倍），服务器受到字符后又将他转换成二进制值.存储过程就没有这些动作: 方法：Create procedure p_insert as insert into table(Fimage) values (@image), 在前台调用这个存储过程传入二进制参数，这样处理速度明显改善。 29、Between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。 select * from chineseresume where title in (‘男’,’女’) Select * from chineseresume where between ‘男’ and ‘女’ 是一样的。由于in会在比较多次，所以有时会慢些。 30、在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。 31、不要建没有作用的事物例如产生报表时，浪费资源。只有在必要使用事物时使用它。 32、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用UNION all执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。 33、尽量少用视图，它的效率低。对视图操作比直接对表操作慢,可以用stored procedure来代替她。特别的是不要用视图嵌套,嵌套视图增加了寻找原始资料的难度。我们看视图的本质：它是存放在服务器上的被优化好了的已经产生了查询规划的SQL。对单个表检索数据时，不要使用指向多个表的视图，直接从表检索或者仅仅包含这个表的视图上读，否则增加了不必要的开销,查询受到干扰.为了加快视图的查询，MsSQL增加了视图索引的功能。 34、没有必要时不要用DISTINCT和ORDER BY，这些动作可以改在客户端执行。它们增加了额外的开销。这同UNION 和UNION ALL一样的道理。 SELECT top 20 ad.companyname,comid,position,ad.referenceid,worklocation, convert(varchar(10),ad.postDate,120) as postDate1,workyear,degreedescription FROM jobcn_query.dbo.COMPANYAD_query ad where referenceID in(‘JCNAD00329667’,’JCNAD132168’,’JCNAD00337748’,’JCNAD00338345’,’JCNAD00333138’,’JCNAD00303570’, ‘JCNAD00303569’,’JCNAD00303568’,’JCNAD00306698’,’JCNAD00231935’,’JCNAD00231933’,’JCNAD00254567’, ‘JCNAD00254585’,’JCNAD00254608’,’JCNAD00254607’,’JCNAD00258524’,’JCNAD00332133’,’JCNAD00268618’, ‘JCNAD00279196’,’JCNAD00268613’) order by postdate desc 35、在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，减少判断的次数 36、当用SELECT INTO时，它会锁住系统表(sysobjects，sysindexes等等)，阻塞其他的连接的存取。创建临时表时用显示申明语句，而不是 select INTO. drop table t_lxh begin tran select * into t_lxh from chineseresume where name = ‘XYZ’ –commit 在另一个连接中SELECT * from sysobjects可以看到 SELECT INTO 会锁住系统表，Create table 也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。 37、一般在GROUP BY 个HAVING字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：select 的Where字句选择所有合适的行，Group By用来分组个统计行，Having字句用来剔除多余的分组。这样Group By 个Having的开销小，查询快.对于大的数据行进行分组和Having十分消耗资源。如果Group BY的目的不包括计算，只是分组，那么用Distinct更快 38、一次更新多条记录比分多次更新每次一条快,就是说批处理好 39、少用临时表，尽量用结果集和Table类性的变量来代替它,Table 类型的变量比临时表好 40、在SQL2000下，计算字段是可以索引的，需要满足的条件如下： a、计算字段的表达是确定的 b、不能用在TEXT,Ntext，Image数据类型 c、必须配制如下选项 ANSI_NULLS = ON, ANSI_PADDINGS = ON, ……. 41、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过、并且被组织到一个执行规划里、且存储在数据库中的 SQL语句，是控制流语言的集合，速度当然快。反复执行的动态SQL,可以使用临时存储过程，该过程（临时表）被放在Tempdb中。以前由于SQL SERVER对复杂的数学计算不支持，所以不得不将这个工作放在其他的层上而增加网络的开销。SQL2000支持UDFs,现在支持复杂的数学计算，函数的返回值不要太大，这样的开销很大。用户自定义函数象光标一样执行的消耗大量的资源，如果返回大的结果采用存储过程 42、不要在一句话里再三的使用相同的函数，浪费资源,将结果放在变量里再调用更快 43、SELECT COUNT(*)的效率教低，尽量变通他的写法，而EXISTS快.同时请注意区别： select count(Field of null) from Table 和 select count(Field of NOT null) from Table 的返回值是不同的。 44、当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用 配制线程数量 &amp;lt;最大连接数启用SQL SERVER的线程池来解决,如果还是数量 = 最大连接数+5，严重的损害服务器的性能。 45、按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A，这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现 46、通过SQL Server Performance Monitor监视相应硬件的负载 Memory: Page Faults / sec计数器如果该值偶尔走高，表明当时有线程竞争内存。如果持续很高，则内存可能是瓶颈。 Process: 1、% DPC Time 指在范例间隔期间处理器用在缓延程序调用(DPC)接收和提供服务的百分比。(DPC 正在运行的为比标准间隔优先权低的间隔)。 由于 DPC 是以特权模式执行的，DPC 时间的百分比为特权时间 百分比的一部分。这些时间单独计算并且不属于间隔计算总数的一部 分。这个总数显示了作为实例时间百分比的平均忙时。 2、%Processor Time计数器　如果该参数值持续超过95%，表明瓶颈是CPU。可以考虑增加一个处理器或换一个更快的处理器。 3、% Privileged Time 指非闲置处理器时间用于特权模式的百分比。(特权模式是为操作系统组件和操纵硬件驱动程序而设计的一种处理模式。它允许直接访问硬件和所有内存。另一种模式为用户模式，它是一种为应用程序、环境分系统和整数分系统设计的一种有限处理模式。操作系统将应用程序线程转换成特权模式以访问操作系统服务)。 特权时间的 % 包括为间断和 DPC 提供服务的时间。特权时间比率高可能是由于失败设备产生的大数量的间隔而引起的。这个计数器将平均忙时作为样本时间的一部分显示。 4、% User Time表示耗费CPU的数据库操作，如排序，执行aggregate functions等。如果该值很高，可考虑增加索引，尽量使用简单的表联接，水平分割大表格等方法来降低该值。 Physical Disk: Curretn Disk Queue Length计数器该值应不超过磁盘数的1.5~2倍。要提高性能，可增加磁盘。 SQLServer:Cache Hit Ratio计数器该值越高越好。如果持续低于80%，应考虑增加内存。 注意该参数值是从SQL Server启动后，就一直累加记数，所以运行经过一段时间后，该值将不能反映系统当前值。 47、分析select emp_name form employee where salary &amp;gt; 3000 在此语句中若salary是Float类型的，则优化器对其进行优化为Convert(float,3000)，因为3000是个整数，我们应在编程时使用3000.0而不要等运行时让DBMS进行转化。同样字符和整型数据的转换。 --查找所有索引 SELECT 'dbcc showcontig (' + CONVERT(VARCHAR(20), i.id) + ',' + -- table id CONVERT(VARCHAR(20), i.indid) + ')--' + --index id OBJECT_NAME(i.id) + '.' + -- table name i.name--index name FROM sysobjects o INNER JOIN sysindexes i ON ( o.id = i.id ) WHERE o.type = 'U' AND i.indid &amp;lt; 2 AND i.id = OBJECT_ID(o.name) ORDER BY OBJECT_NAME(i.id), i.indid --结果 dbcc showcontig (2052202361,1)--AddBusiness.PK_AddBusiness 何时需要重建索引： DBCC showcontig(‘Send’)</summary></entry><entry><title type="html">mysql视图的作用（详细）</title><link href="http://localhost:4000/mianshi/mysql/0708/02" rel="alternate" type="text/html" title="mysql视图的作用（详细）" /><published>2020-07-08T00:00:00+08:00</published><updated>2020-07-08T00:00:00+08:00</updated><id>http://localhost:4000/mianshi/mysql/0708/mysql%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8(%E8%AF%A6%E7%BB%86)</id><content type="html" xml:base="http://localhost:4000/mianshi/mysql/0708/02">&lt;h4 id=&quot;测试表&quot;&gt;测试表：&lt;/h4&gt;

&lt;p&gt;测试表:user有id，name，age，sex字段&lt;/p&gt;

&lt;p&gt;测试表:goods有id，name，price字段&lt;/p&gt;

&lt;p&gt;测试表:ug有id，userid，goodsid字段&lt;/p&gt;

&lt;p&gt;视图的作用实在是太强大了，以下是我体验过的好处：&lt;/p&gt;

&lt;h4 id=&quot;作用一提高了重用性&quot;&gt;作用一：提高了重用性&lt;/h4&gt;
&lt;p&gt;提高了重用性，就像一个函数。如果要频繁获取user的name和goods的name。就应该使用以下sql语言。示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但有了视图就不一样了，创建视图other。示例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建好视图后，就可以这样获取user的name和goods的name。示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;select * from other;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上sql语句，就能获取user的name和goods的name了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;作用二：&lt;/strong&gt;
对数据库重构，却不影响程序的运行。假如因为某种需求，需要将user拆房表usera和表userb，该两张表的结构如下：&lt;/p&gt;

&lt;p&gt;测试表:usera有id，name，age字段&lt;/p&gt;

&lt;p&gt;测试表:userb有id，name，sex字段&lt;/p&gt;

&lt;p&gt;这时如果php端使用sql语句：select * from user;那就会提示该表不存在，这时该如何解决呢。解决方案：创建视图。以下sql语句创建视图：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt;create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上假设name都是唯一的。此时php端使用sql语句：select * from user;就不会报错什么的。这就__实现了更改数据库结构，不更改脚本程序的功能了__。&lt;/p&gt;

&lt;h4 id=&quot;作用三安全性能&quot;&gt;作用三：安全性能&lt;/h4&gt;

&lt;p&gt;提高了安全性能。可以对不同的用户，设定不同的视图。例如：某用户只能获取user表的name和age数据，不能获取sex数据。则可以这样创建视图。示例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-mysql&quot;&gt; create view other as select a.name, a.age from user as a;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话，使用sql语句：select * from other; 最多就只能获取name和age的数据，其他的数据就获取不了了。&lt;/p&gt;

&lt;h4 id=&quot;作用四数据更加清晰&quot;&gt;作用四：数据更加清晰&lt;/h4&gt;

&lt;p&gt;让数据更加清晰。想要什么样的数据，就创建什么样的视图。经过以上三条作用的解析，这条作用应该很容易理解了吧&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点及缺点&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;简单化，数据所见即所得&lt;/p&gt;

  &lt;p&gt;安全性，用户只能查询或修改他们所能见到得到的数据&lt;/p&gt;

  &lt;p&gt;逻辑独立性，可以屏蔽真实表结构变化带来的影响&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;性能相对较差，简单的查询也会变得稍显复杂&lt;/p&gt;

  &lt;p&gt;修改不方便，特变是复杂的聚合视图基本无法修改&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>java牛牛</name><email>king101125s@gmail.com</email></author><category term="post" /><category term="面试题" /><summary type="html">测试表： 测试表:user有id，name，age，sex字段 测试表:goods有id，name，price字段 测试表:ug有id，userid，goodsid字段 视图的作用实在是太强大了，以下是我体验过的好处： 作用一：提高了重用性 提高了重用性，就像一个函数。如果要频繁获取user的name和goods的name。就应该使用以下sql语言。示例： select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id; 但有了视图就不一样了，创建视图other。示例 create view other as select a.name as username, b.name as goodsname from user as a, goods as b, ug as c where a.id=c.userid and c.goodsid=b.id; 创建好视图后，就可以这样获取user的name和goods的name。示例： select * from other; 以上sql语句，就能获取user的name和goods的name了。 作用二： 对数据库重构，却不影响程序的运行。假如因为某种需求，需要将user拆房表usera和表userb，该两张表的结构如下： 测试表:usera有id，name，age字段 测试表:userb有id，name，sex字段 这时如果php端使用sql语句：select * from user;那就会提示该表不存在，这时该如何解决呢。解决方案：创建视图。以下sql语句创建视图： create view user as select a.name,a.age,b.sex from usera as a, userb as b where a.name=b.name; 以上假设name都是唯一的。此时php端使用sql语句：select * from user;就不会报错什么的。这就__实现了更改数据库结构，不更改脚本程序的功能了__。 作用三：安全性能 提高了安全性能。可以对不同的用户，设定不同的视图。例如：某用户只能获取user表的name和age数据，不能获取sex数据。则可以这样创建视图。示例如下： create view other as select a.name, a.age from user as a; 这样的话，使用sql语句：select * from other; 最多就只能获取name和age的数据，其他的数据就获取不了了。 作用四：数据更加清晰 让数据更加清晰。想要什么样的数据，就创建什么样的视图。经过以上三条作用的解析，这条作用应该很容易理解了吧 优点及缺点 优点 简单化，数据所见即所得 安全性，用户只能查询或修改他们所能见到得到的数据 逻辑独立性，可以屏蔽真实表结构变化带来的影响 缺点 性能相对较差，简单的查询也会变得稍显复杂 修改不方便，特变是复杂的聚合视图基本无法修改</summary></entry></feed>